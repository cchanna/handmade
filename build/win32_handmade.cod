; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.22816.0 

	TITLE	P:\handmade\code\win32_handmade.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z	; XInputGetStateStub
PUBLIC	?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; XInputSetStateStub
CONST	SEGMENT
$SG87698 DB	'xinput1_4.dll', 00H
	ORG $+2
$SG87700 DB	'xinput9_1_0.dll', 00H
$SG87702 DB	'xinput1_3.dll', 00H
	ORG $+2
$SG87705 DB	'XInputGetState', 00H
	ORG $+1
$SG87707 DB	'XInputSetState', 00H
	ORG $+1
$SG87729 DB	'dsound.dll', 00H
	ORG $+1
$SG87731 DB	'DirectSoundCreate', 00H
	ORG $+2
$SG87740 DB	'Primary buffer format was set.', 0aH, 00H
$SG87742 DB	'Secondary buffer created successfuly', 0aH, 00H
	ORG $+2
$SG87779 DB	'WM_ACTIVATEAPP', 0aH, 00H
$SG87783 DB	'Keyboard input came in through a non-dispatch message!', 00H
	ORG $+1
$SG87785 DB	'WM_PAINT', 0aH, 00H
	ORG $+2
$SG3988	DB	'p:\handmade\code\handmade.cpp', 00H
	ORG $+2
$SG3990	DB	'test.out', 00H
	ORG $+3
$SG87959 DB	'HandmadeHeroWindowClass', 00H
$SG87962 DB	'Handmade Hero', 00H
CONST	ENDS
_DATA	SEGMENT
?XInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA DD FLAT:?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ; XInputGetState_
?XInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA DD FLAT:?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; XInputSetState_
_DATA	ENDS
PUBLIC	_sinf
PUBLIC	_WinMain@16
PUBLIC	?SafeTruncateUInt64@@YAI_K@Z			; SafeTruncateUInt64
PUBLIC	__real@40800000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40c90fdb
PUBLIC	__real@412e848000000000
PUBLIC	__real@43000000
PUBLIC	__real@46fffe00
PUBLIC	__real@47000000
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__GetFileSizeEx@8:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__VirtualAlloc@16:PROC
EXTRN	__imp__VirtualFree@12:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__StretchDIBits@52:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	__ltod3:PROC
EXTRN	__ultod3:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?tSine@?1??GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z@4MA
_BSS	SEGMENT
?tSine@?1??GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z@4MA DD 01H DUP (?) ; `GameOutputSound'::`2'::tSine
_BSS	ENDS
_BSS	SEGMENT
?GlobalRunning@@3HA DD 01H DUP (?)			; GlobalRunning
?GlobalBackbuffer@@3Uwin32_offscreen_buffer@@A DB 040H DUP (?) ; GlobalBackbuffer
?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A DD 01H DUP (?) ; GlobalSecondaryBuffer
_BSS	ENDS
;	COMDAT __real@47000000
CONST	SEGMENT
__real@47000000 DD 047000000r			; 32768
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+06
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_Message$ = -52						; size = 28
_WasDown$1 = -24					; size = 4
tv77 = -20						; size = 4
tv74 = -16						; size = 4
tv71 = -12						; size = 4
_IsDown$2 = -8						; size = 4
_VKCode$3 = -4						; size = 4
_KeyboardController$ = 8				; size = 4
?Win32ProcessPendingMessage@@YAXPAUgame_controller_input@@@Z PROC ; Win32ProcessPendingMessage

; 471  : Win32ProcessPendingMessage(game_controller_input *KeyboardController) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
$LN2@Win32Proce:

; 472  :     MSG Message;
; 473  :     while (PeekMessage(&Message, 0, 0, 0, PM_REMOVE)) {

  00006	6a 01		 push	 1
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	8d 45 cc	 lea	 eax, DWORD PTR _Message$[ebp]
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 a6 01 00
	00		 je	 $LN1@Win32Proce

; 474  :         switch(Message.message) {

  00020	8b 4d d0	 mov	 ecx, DWORD PTR _Message$[ebp+4]
  00023	89 4d f4	 mov	 DWORD PTR tv71[ebp], ecx
  00026	8b 55 f4	 mov	 edx, DWORD PTR tv71[ebp]
  00029	83 ea 12	 sub	 edx, 18			; 00000012H
  0002c	89 55 f4	 mov	 DWORD PTR tv71[ebp], edx
  0002f	81 7d f4 f3 00
	00 00		 cmp	 DWORD PTR tv71[ebp], 243 ; 000000f3H
  00036	0f 87 71 01 00
	00		 ja	 $LN33@Win32Proce
  0003c	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  0003f	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN39@Win32Proce[eax]
  00046	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN40@Win32Proce[ecx*4]
$LN6@Win32Proce:

; 475  :             case WM_QUIT: {
; 476  :                 GlobalRunning = false;

  0004d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 477  :             } break;

  00057	e9 65 01 00 00	 jmp	 $LN4@Win32Proce
$LN7@Win32Proce:

; 478  :             case WM_SYSKEYDOWN:
; 479  :             case WM_SYSKEYUP:
; 480  :             case WM_KEYDOWN:
; 481  :             case WM_KEYUP: {
; 482  :                 uint32 VKCode = (uint32)Message.wParam;

  0005c	8b 55 d4	 mov	 edx, DWORD PTR _Message$[ebp+8]
  0005f	89 55 fc	 mov	 DWORD PTR _VKCode$3[ebp], edx

; 483  :                 bool32 WasDown = ((Message.lParam & (1 << 30)) != 0);

  00062	8b 45 d8	 mov	 eax, DWORD PTR _Message$[ebp+12]
  00065	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0006a	74 09		 je	 SHORT $LN35@Win32Proce
  0006c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00073	eb 07		 jmp	 SHORT $LN36@Win32Proce
$LN35@Win32Proce:
  00075	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN36@Win32Proce:
  0007c	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  0007f	89 4d e8	 mov	 DWORD PTR _WasDown$1[ebp], ecx

; 484  :                 bool32 IsDown = ((Message.lParam & (1 << 31)) == 0);

  00082	8b 55 d8	 mov	 edx, DWORD PTR _Message$[ebp+12]
  00085	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  0008b	75 09		 jne	 SHORT $LN37@Win32Proce
  0008d	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  00094	eb 07		 jmp	 SHORT $LN38@Win32Proce
$LN37@Win32Proce:
  00096	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN38@Win32Proce:
  0009d	8b 45 ec	 mov	 eax, DWORD PTR tv77[ebp]
  000a0	89 45 f8	 mov	 DWORD PTR _IsDown$2[ebp], eax

; 485  :                 if(WasDown != IsDown) {

  000a3	8b 4d e8	 mov	 ecx, DWORD PTR _WasDown$1[ebp]
  000a6	3b 4d f8	 cmp	 ecx, DWORD PTR _IsDown$2[ebp]
  000a9	0f 84 fc 00 00
	00		 je	 $LN8@Win32Proce

; 486  :                     if(VKCode == 'W') {

  000af	83 7d fc 57	 cmp	 DWORD PTR _VKCode$3[ebp], 87 ; 00000057H
  000b3	75 05		 jne	 SHORT $LN9@Win32Proce
  000b5	e9 d6 00 00 00	 jmp	 $LN10@Win32Proce
$LN9@Win32Proce:

; 487  :                     }
; 488  :                     else if(VKCode == 'A') {

  000ba	83 7d fc 41	 cmp	 DWORD PTR _VKCode$3[ebp], 65 ; 00000041H
  000be	75 05		 jne	 SHORT $LN11@Win32Proce
  000c0	e9 cb 00 00 00	 jmp	 $LN10@Win32Proce
$LN11@Win32Proce:

; 489  :                     }
; 490  :                     else if(VKCode == 'S') {

  000c5	83 7d fc 53	 cmp	 DWORD PTR _VKCode$3[ebp], 83 ; 00000053H
  000c9	75 05		 jne	 SHORT $LN13@Win32Proce
  000cb	e9 c0 00 00 00	 jmp	 $LN10@Win32Proce
$LN13@Win32Proce:

; 491  :                     }
; 492  :                     else if(VKCode == 'D') {

  000d0	83 7d fc 44	 cmp	 DWORD PTR _VKCode$3[ebp], 68 ; 00000044H
  000d4	75 05		 jne	 SHORT $LN15@Win32Proce
  000d6	e9 b5 00 00 00	 jmp	 $LN10@Win32Proce
$LN15@Win32Proce:

; 493  :                     }
; 494  :                     else if(VKCode == 'Q') {

  000db	83 7d fc 51	 cmp	 DWORD PTR _VKCode$3[ebp], 81 ; 00000051H
  000df	75 18		 jne	 SHORT $LN17@Win32Proce

; 495  :                         Win32ProcessKeyboardMessage(&KeyboardController->LeftShoulder, IsDown);

  000e1	8b 55 f8	 mov	 edx, DWORD PTR _IsDown$2[ebp]
  000e4	52		 push	 edx
  000e5	8b 45 08	 mov	 eax, DWORD PTR _KeyboardController$[ebp]
  000e8	83 c0 44	 add	 eax, 68			; 00000044H
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ?Win32ProcessKeyboardMessage@@YAXPAUgame_button_state@@H@Z ; Win32ProcessKeyboardMessage
  000f1	83 c4 08	 add	 esp, 8
  000f4	e9 97 00 00 00	 jmp	 $LN10@Win32Proce
$LN17@Win32Proce:

; 496  :                     }
; 497  :                     else if(VKCode == 'E') {

  000f9	83 7d fc 45	 cmp	 DWORD PTR _VKCode$3[ebp], 69 ; 00000045H
  000fd	75 15		 jne	 SHORT $LN19@Win32Proce

; 498  :                         Win32ProcessKeyboardMessage(&KeyboardController->RightShoulder, IsDown);

  000ff	8b 4d f8	 mov	 ecx, DWORD PTR _IsDown$2[ebp]
  00102	51		 push	 ecx
  00103	8b 55 08	 mov	 edx, DWORD PTR _KeyboardController$[ebp]
  00106	83 c2 4c	 add	 edx, 76			; 0000004cH
  00109	52		 push	 edx
  0010a	e8 00 00 00 00	 call	 ?Win32ProcessKeyboardMessage@@YAXPAUgame_button_state@@H@Z ; Win32ProcessKeyboardMessage
  0010f	83 c4 08	 add	 esp, 8
  00112	eb 7c		 jmp	 SHORT $LN10@Win32Proce
$LN19@Win32Proce:

; 499  :                     }
; 500  :                     else if(VKCode == VK_UP) {

  00114	83 7d fc 26	 cmp	 DWORD PTR _VKCode$3[ebp], 38 ; 00000026H
  00118	75 15		 jne	 SHORT $LN21@Win32Proce

; 501  :                         Win32ProcessKeyboardMessage(&KeyboardController->Up, IsDown);

  0011a	8b 45 f8	 mov	 eax, DWORD PTR _IsDown$2[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _KeyboardController$[ebp]
  00121	83 c1 24	 add	 ecx, 36			; 00000024H
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 ?Win32ProcessKeyboardMessage@@YAXPAUgame_button_state@@H@Z ; Win32ProcessKeyboardMessage
  0012a	83 c4 08	 add	 esp, 8
  0012d	eb 61		 jmp	 SHORT $LN10@Win32Proce
$LN21@Win32Proce:

; 502  :                     }
; 503  :                     else if(VKCode == VK_DOWN) {

  0012f	83 7d fc 28	 cmp	 DWORD PTR _VKCode$3[ebp], 40 ; 00000028H
  00133	75 15		 jne	 SHORT $LN23@Win32Proce

; 504  :                         Win32ProcessKeyboardMessage(&KeyboardController->Down, IsDown);

  00135	8b 55 f8	 mov	 edx, DWORD PTR _IsDown$2[ebp]
  00138	52		 push	 edx
  00139	8b 45 08	 mov	 eax, DWORD PTR _KeyboardController$[ebp]
  0013c	83 c0 2c	 add	 eax, 44			; 0000002cH
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ?Win32ProcessKeyboardMessage@@YAXPAUgame_button_state@@H@Z ; Win32ProcessKeyboardMessage
  00145	83 c4 08	 add	 esp, 8
  00148	eb 46		 jmp	 SHORT $LN10@Win32Proce
$LN23@Win32Proce:

; 505  :                     }
; 506  :                     else if(VKCode == VK_LEFT) {

  0014a	83 7d fc 25	 cmp	 DWORD PTR _VKCode$3[ebp], 37 ; 00000025H
  0014e	75 15		 jne	 SHORT $LN25@Win32Proce

; 507  :                         Win32ProcessKeyboardMessage(&KeyboardController->Left, IsDown);

  00150	8b 4d f8	 mov	 ecx, DWORD PTR _IsDown$2[ebp]
  00153	51		 push	 ecx
  00154	8b 55 08	 mov	 edx, DWORD PTR _KeyboardController$[ebp]
  00157	83 c2 34	 add	 edx, 52			; 00000034H
  0015a	52		 push	 edx
  0015b	e8 00 00 00 00	 call	 ?Win32ProcessKeyboardMessage@@YAXPAUgame_button_state@@H@Z ; Win32ProcessKeyboardMessage
  00160	83 c4 08	 add	 esp, 8
  00163	eb 2b		 jmp	 SHORT $LN10@Win32Proce
$LN25@Win32Proce:

; 508  :                     }
; 509  :                     else if(VKCode == VK_RIGHT) {

  00165	83 7d fc 27	 cmp	 DWORD PTR _VKCode$3[ebp], 39 ; 00000027H
  00169	75 15		 jne	 SHORT $LN27@Win32Proce

; 510  :                         Win32ProcessKeyboardMessage(&KeyboardController->Right, IsDown);

  0016b	8b 45 f8	 mov	 eax, DWORD PTR _IsDown$2[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d 08	 mov	 ecx, DWORD PTR _KeyboardController$[ebp]
  00172	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00175	51		 push	 ecx
  00176	e8 00 00 00 00	 call	 ?Win32ProcessKeyboardMessage@@YAXPAUgame_button_state@@H@Z ; Win32ProcessKeyboardMessage
  0017b	83 c4 08	 add	 esp, 8
  0017e	eb 10		 jmp	 SHORT $LN10@Win32Proce
$LN27@Win32Proce:

; 511  :                     }
; 512  :                     else if(VKCode == VK_ESCAPE) {

  00180	83 7d fc 1b	 cmp	 DWORD PTR _VKCode$3[ebp], 27 ; 0000001bH
  00184	75 0a		 jne	 SHORT $LN10@Win32Proce

; 513  :                         GlobalRunning = false;

  00186	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN10@Win32Proce:

; 514  :                     }
; 515  :                     else if(VKCode == VK_SPACE) {
; 516  :                     }
; 517  :                     if((Message.lParam & (1 << 29)) && VKCode == VK_F4) { //Alt+F4

  00190	8b 55 d8	 mov	 edx, DWORD PTR _Message$[ebp+12]
  00193	81 e2 00 00 00
	20		 and	 edx, 536870912		; 20000000H
  00199	74 10		 je	 SHORT $LN8@Win32Proce
  0019b	83 7d fc 73	 cmp	 DWORD PTR _VKCode$3[ebp], 115 ; 00000073H
  0019f	75 0a		 jne	 SHORT $LN8@Win32Proce

; 518  :                         GlobalRunning = false;

  001a1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0
$LN8@Win32Proce:

; 519  :                     }
; 520  :                 }
; 521  :             } break;

  001ab	eb 14		 jmp	 SHORT $LN4@Win32Proce
$LN33@Win32Proce:

; 522  : 
; 523  :             default: {
; 524  :                 TranslateMessage(&Message);

  001ad	8d 45 cc	 lea	 eax, DWORD PTR _Message$[ebp]
  001b0	50		 push	 eax
  001b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateMessage@4

; 525  :                 DispatchMessageA(&Message);

  001b7	8d 4d cc	 lea	 ecx, DWORD PTR _Message$[ebp]
  001ba	51		 push	 ecx
  001bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DispatchMessageA@4
$LN4@Win32Proce:

; 526  :             }
; 527  :         }
; 528  : 
; 529  :         // TODO Should we poll this more frequently
; 530  : 
; 531  :     }

  001c1	e9 40 fe ff ff	 jmp	 $LN2@Win32Proce
$LN1@Win32Proce:

; 532  : }

  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c3		 ret	 0
  001ca	66 90		 npad	 2
$LN40@Win32Proce:
  001cc	00 00 00 00	 DD	 $LN6@Win32Proce
  001d0	00 00 00 00	 DD	 $LN7@Win32Proce
  001d4	00 00 00 00	 DD	 $LN33@Win32Proce
$LN39@Win32Proce:
  001d8	00		 DB	 0
  001d9	02		 DB	 2
  001da	02		 DB	 2
  001db	02		 DB	 2
  001dc	02		 DB	 2
  001dd	02		 DB	 2
  001de	02		 DB	 2
  001df	02		 DB	 2
  001e0	02		 DB	 2
  001e1	02		 DB	 2
  001e2	02		 DB	 2
  001e3	02		 DB	 2
  001e4	02		 DB	 2
  001e5	02		 DB	 2
  001e6	02		 DB	 2
  001e7	02		 DB	 2
  001e8	02		 DB	 2
  001e9	02		 DB	 2
  001ea	02		 DB	 2
  001eb	02		 DB	 2
  001ec	02		 DB	 2
  001ed	02		 DB	 2
  001ee	02		 DB	 2
  001ef	02		 DB	 2
  001f0	02		 DB	 2
  001f1	02		 DB	 2
  001f2	02		 DB	 2
  001f3	02		 DB	 2
  001f4	02		 DB	 2
  001f5	02		 DB	 2
  001f6	02		 DB	 2
  001f7	02		 DB	 2
  001f8	02		 DB	 2
  001f9	02		 DB	 2
  001fa	02		 DB	 2
  001fb	02		 DB	 2
  001fc	02		 DB	 2
  001fd	02		 DB	 2
  001fe	02		 DB	 2
  001ff	02		 DB	 2
  00200	02		 DB	 2
  00201	02		 DB	 2
  00202	02		 DB	 2
  00203	02		 DB	 2
  00204	02		 DB	 2
  00205	02		 DB	 2
  00206	02		 DB	 2
  00207	02		 DB	 2
  00208	02		 DB	 2
  00209	02		 DB	 2
  0020a	02		 DB	 2
  0020b	02		 DB	 2
  0020c	02		 DB	 2
  0020d	02		 DB	 2
  0020e	02		 DB	 2
  0020f	02		 DB	 2
  00210	02		 DB	 2
  00211	02		 DB	 2
  00212	02		 DB	 2
  00213	02		 DB	 2
  00214	02		 DB	 2
  00215	02		 DB	 2
  00216	02		 DB	 2
  00217	02		 DB	 2
  00218	02		 DB	 2
  00219	02		 DB	 2
  0021a	02		 DB	 2
  0021b	02		 DB	 2
  0021c	02		 DB	 2
  0021d	02		 DB	 2
  0021e	02		 DB	 2
  0021f	02		 DB	 2
  00220	02		 DB	 2
  00221	02		 DB	 2
  00222	02		 DB	 2
  00223	02		 DB	 2
  00224	02		 DB	 2
  00225	02		 DB	 2
  00226	02		 DB	 2
  00227	02		 DB	 2
  00228	02		 DB	 2
  00229	02		 DB	 2
  0022a	02		 DB	 2
  0022b	02		 DB	 2
  0022c	02		 DB	 2
  0022d	02		 DB	 2
  0022e	02		 DB	 2
  0022f	02		 DB	 2
  00230	02		 DB	 2
  00231	02		 DB	 2
  00232	02		 DB	 2
  00233	02		 DB	 2
  00234	02		 DB	 2
  00235	02		 DB	 2
  00236	02		 DB	 2
  00237	02		 DB	 2
  00238	02		 DB	 2
  00239	02		 DB	 2
  0023a	02		 DB	 2
  0023b	02		 DB	 2
  0023c	02		 DB	 2
  0023d	02		 DB	 2
  0023e	02		 DB	 2
  0023f	02		 DB	 2
  00240	02		 DB	 2
  00241	02		 DB	 2
  00242	02		 DB	 2
  00243	02		 DB	 2
  00244	02		 DB	 2
  00245	02		 DB	 2
  00246	02		 DB	 2
  00247	02		 DB	 2
  00248	02		 DB	 2
  00249	02		 DB	 2
  0024a	02		 DB	 2
  0024b	02		 DB	 2
  0024c	02		 DB	 2
  0024d	02		 DB	 2
  0024e	02		 DB	 2
  0024f	02		 DB	 2
  00250	02		 DB	 2
  00251	02		 DB	 2
  00252	02		 DB	 2
  00253	02		 DB	 2
  00254	02		 DB	 2
  00255	02		 DB	 2
  00256	02		 DB	 2
  00257	02		 DB	 2
  00258	02		 DB	 2
  00259	02		 DB	 2
  0025a	02		 DB	 2
  0025b	02		 DB	 2
  0025c	02		 DB	 2
  0025d	02		 DB	 2
  0025e	02		 DB	 2
  0025f	02		 DB	 2
  00260	02		 DB	 2
  00261	02		 DB	 2
  00262	02		 DB	 2
  00263	02		 DB	 2
  00264	02		 DB	 2
  00265	02		 DB	 2
  00266	02		 DB	 2
  00267	02		 DB	 2
  00268	02		 DB	 2
  00269	02		 DB	 2
  0026a	02		 DB	 2
  0026b	02		 DB	 2
  0026c	02		 DB	 2
  0026d	02		 DB	 2
  0026e	02		 DB	 2
  0026f	02		 DB	 2
  00270	02		 DB	 2
  00271	02		 DB	 2
  00272	02		 DB	 2
  00273	02		 DB	 2
  00274	02		 DB	 2
  00275	02		 DB	 2
  00276	02		 DB	 2
  00277	02		 DB	 2
  00278	02		 DB	 2
  00279	02		 DB	 2
  0027a	02		 DB	 2
  0027b	02		 DB	 2
  0027c	02		 DB	 2
  0027d	02		 DB	 2
  0027e	02		 DB	 2
  0027f	02		 DB	 2
  00280	02		 DB	 2
  00281	02		 DB	 2
  00282	02		 DB	 2
  00283	02		 DB	 2
  00284	02		 DB	 2
  00285	02		 DB	 2
  00286	02		 DB	 2
  00287	02		 DB	 2
  00288	02		 DB	 2
  00289	02		 DB	 2
  0028a	02		 DB	 2
  0028b	02		 DB	 2
  0028c	02		 DB	 2
  0028d	02		 DB	 2
  0028e	02		 DB	 2
  0028f	02		 DB	 2
  00290	02		 DB	 2
  00291	02		 DB	 2
  00292	02		 DB	 2
  00293	02		 DB	 2
  00294	02		 DB	 2
  00295	02		 DB	 2
  00296	02		 DB	 2
  00297	02		 DB	 2
  00298	02		 DB	 2
  00299	02		 DB	 2
  0029a	02		 DB	 2
  0029b	02		 DB	 2
  0029c	02		 DB	 2
  0029d	02		 DB	 2
  0029e	02		 DB	 2
  0029f	02		 DB	 2
  002a0	02		 DB	 2
  002a1	02		 DB	 2
  002a2	02		 DB	 2
  002a3	02		 DB	 2
  002a4	02		 DB	 2
  002a5	02		 DB	 2
  002a6	02		 DB	 2
  002a7	02		 DB	 2
  002a8	02		 DB	 2
  002a9	02		 DB	 2
  002aa	02		 DB	 2
  002ab	02		 DB	 2
  002ac	02		 DB	 2
  002ad	02		 DB	 2
  002ae	02		 DB	 2
  002af	02		 DB	 2
  002b0	02		 DB	 2
  002b1	02		 DB	 2
  002b2	02		 DB	 2
  002b3	02		 DB	 2
  002b4	02		 DB	 2
  002b5	02		 DB	 2
  002b6	02		 DB	 2
  002b7	02		 DB	 2
  002b8	02		 DB	 2
  002b9	02		 DB	 2
  002ba	02		 DB	 2
  002bb	02		 DB	 2
  002bc	02		 DB	 2
  002bd	02		 DB	 2
  002be	02		 DB	 2
  002bf	02		 DB	 2
  002c0	02		 DB	 2
  002c1	02		 DB	 2
  002c2	02		 DB	 2
  002c3	02		 DB	 2
  002c4	02		 DB	 2
  002c5	02		 DB	 2
  002c6	01		 DB	 1
  002c7	01		 DB	 1
  002c8	02		 DB	 2
  002c9	02		 DB	 2
  002ca	01		 DB	 1
  002cb	01		 DB	 1
?Win32ProcessPendingMessage@@YAXPAUgame_controller_input@@@Z ENDP ; Win32ProcessPendingMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_NewState$ = 8						; size = 4
_IsDown$ = 12						; size = 4
?Win32ProcessKeyboardMessage@@YAXPAUgame_button_state@@H@Z PROC ; Win32ProcessKeyboardMessage

; 463  : Win32ProcessKeyboardMessage(game_button_state *NewState, bool32 IsDown) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 464  :     NewState->EndedDown = IsDown;

  00003	8b 45 08	 mov	 eax, DWORD PTR _NewState$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _IsDown$[ebp]
  00009	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 465  :     ++NewState->HalfTransitionCount;  

  0000c	8b 55 08	 mov	 edx, DWORD PTR _NewState$[ebp]
  0000f	8b 02		 mov	 eax, DWORD PTR [edx]
  00011	83 c0 01	 add	 eax, 1
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _NewState$[ebp]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 466  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?Win32ProcessKeyboardMessage@@YAXPAUgame_button_state@@H@Z ENDP ; Win32ProcessKeyboardMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
tv72 = -8						; size = 4
tv67 = -4						; size = 4
_XInputButtonState$ = 8					; size = 4
_OldState$ = 12						; size = 4
_NewState$ = 16						; size = 4
_ButtonBit$ = 20					; size = 4
?Win32ProcessXInputDigitalButton@@YAXKPAUgame_button_state@@0K@Z PROC ; Win32ProcessXInputDigitalButton

; 455  : Win32ProcessXInputDigitalButton(DWORD XInputButtonState, game_button_state *OldState, game_button_state *NewState, DWORD ButtonBit) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 456  :     NewState->EndedDown = (XInputButtonState & ButtonBit) == ButtonBit;

  00006	8b 45 08	 mov	 eax, DWORD PTR _XInputButtonState$[ebp]
  00009	23 45 14	 and	 eax, DWORD PTR _ButtonBit$[ebp]
  0000c	3b 45 14	 cmp	 eax, DWORD PTR _ButtonBit$[ebp]
  0000f	75 09		 jne	 SHORT $LN3@Win32Proce
  00011	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00018	eb 07		 jmp	 SHORT $LN4@Win32Proce
$LN3@Win32Proce:
  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@Win32Proce:
  00021	8b 4d 10	 mov	 ecx, DWORD PTR _NewState$[ebp]
  00024	8b 55 fc	 mov	 edx, DWORD PTR tv67[ebp]
  00027	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 457  :     NewState->HalfTransitionCount = (OldState->EndedDown != NewState->EndedDown) ? 1 : 0;  

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _OldState$[ebp]
  0002d	8b 4d 10	 mov	 ecx, DWORD PTR _NewState$[ebp]
  00030	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00033	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00036	74 09		 je	 SHORT $LN5@Win32Proce
  00038	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  0003f	eb 07		 jmp	 SHORT $LN6@Win32Proce
$LN5@Win32Proce:
  00041	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN6@Win32Proce:
  00048	8b 45 10	 mov	 eax, DWORD PTR _NewState$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR tv72[ebp]
  0004e	89 08		 mov	 DWORD PTR [eax], ecx

; 458  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?Win32ProcessXInputDigitalButton@@YAXKPAUgame_button_state@@0K@Z ENDP ; Win32ProcessXInputDigitalButton
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_Region2SampleCount$1 = -40				; size = 4
_Region1SampleCount$2 = -36				; size = 4
_Region1$ = -32						; size = 4
_Region1Size$ = -28					; size = 4
_Region2$ = -24						; size = 4
_Region2Size$ = -20					; size = 4
_SampleIndex$3 = -16					; size = 4
_SampleIndex$4 = -12					; size = 4
_SourceSample$5 = -8					; size = 4
_DestSample$6 = -4					; size = 4
_SoundOutput$ = 8					; size = 4
_ByteToLock$ = 12					; size = 4
_BytesToWrite$ = 16					; size = 4
_SourceBuffer$ = 20					; size = 4
?win32FillSoundBuffer@@YAXPAUwin32_sound_output@@KKPAUgame_sound_output_buffer@@@Z PROC ; win32FillSoundBuffer

; 418  : win32FillSoundBuffer(win32_sound_output *SoundOutput, DWORD ByteToLock, DWORD BytesToWrite, game_sound_output_buffer *SourceBuffer) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 419  :     VOID *Region1;
; 420  :     DWORD Region1Size;
; 421  :     VOID *Region2;
; 422  :     DWORD Region2Size;
; 423  :     if(SUCCEEDED(GlobalSecondaryBuffer->Lock(

  00006	6a 00		 push	 0
  00008	8d 45 ec	 lea	 eax, DWORD PTR _Region2Size$[ebp]
  0000b	50		 push	 eax
  0000c	8d 4d e8	 lea	 ecx, DWORD PTR _Region2$[ebp]
  0000f	51		 push	 ecx
  00010	8d 55 e4	 lea	 edx, DWORD PTR _Region1Size$[ebp]
  00013	52		 push	 edx
  00014	8d 45 e0	 lea	 eax, DWORD PTR _Region1$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _BytesToWrite$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _ByteToLock$[ebp]
  0001f	52		 push	 edx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  0002d	52		 push	 edx
  0002e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00031	ff d0		 call	 eax
  00033	85 c0		 test	 eax, eax
  00035	0f 8c 22 01 00
	00		 jl	 $LN1@win32FillS

; 424  :         ByteToLock, BytesToWrite,
; 425  :         &Region1, &Region1Size,
; 426  :         &Region2, &Region2Size,
; 427  :         0
; 428  :     ))) {
; 429  :         //TODO Assert that Region1Size/Region2Size is valid
; 430  :         //TODO Collapse these to loops
; 431  :         DWORD Region1SampleCount = Region1Size/SoundOutput->BytesPerSample;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _SoundOutput$[ebp]
  0003e	8b 45 e4	 mov	 eax, DWORD PTR _Region1Size$[ebp]
  00041	33 d2		 xor	 edx, edx
  00043	f7 71 08	 div	 DWORD PTR [ecx+8]
  00046	89 45 dc	 mov	 DWORD PTR _Region1SampleCount$2[ebp], eax

; 432  :         int16 *DestSample = (int16 *)Region1;

  00049	8b 55 e0	 mov	 edx, DWORD PTR _Region1$[ebp]
  0004c	89 55 fc	 mov	 DWORD PTR _DestSample$6[ebp], edx

; 433  :         int16 *SourceSample = SourceBuffer->Samples;

  0004f	8b 45 14	 mov	 eax, DWORD PTR _SourceBuffer$[ebp]
  00052	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00055	89 4d f8	 mov	 DWORD PTR _SourceSample$5[ebp], ecx

; 434  :         for(DWORD SampleIndex = 0; SampleIndex < Region1SampleCount; ++SampleIndex) {

  00058	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _SampleIndex$4[ebp], 0
  0005f	eb 09		 jmp	 SHORT $LN4@win32FillS
$LN2@win32FillS:
  00061	8b 55 f4	 mov	 edx, DWORD PTR _SampleIndex$4[ebp]
  00064	83 c2 01	 add	 edx, 1
  00067	89 55 f4	 mov	 DWORD PTR _SampleIndex$4[ebp], edx
$LN4@win32FillS:
  0006a	8b 45 f4	 mov	 eax, DWORD PTR _SampleIndex$4[ebp]
  0006d	3b 45 dc	 cmp	 eax, DWORD PTR _Region1SampleCount$2[ebp]
  00070	73 4d		 jae	 SHORT $LN3@win32FillS

; 435  :             *DestSample++ = *SourceSample++;

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _DestSample$6[ebp]
  00075	8b 55 f8	 mov	 edx, DWORD PTR _SourceSample$5[ebp]
  00078	66 8b 02	 mov	 ax, WORD PTR [edx]
  0007b	66 89 01	 mov	 WORD PTR [ecx], ax
  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _DestSample$6[ebp]
  00081	83 c1 02	 add	 ecx, 2
  00084	89 4d fc	 mov	 DWORD PTR _DestSample$6[ebp], ecx
  00087	8b 55 f8	 mov	 edx, DWORD PTR _SourceSample$5[ebp]
  0008a	83 c2 02	 add	 edx, 2
  0008d	89 55 f8	 mov	 DWORD PTR _SourceSample$5[ebp], edx

; 436  :             *DestSample++ = *SourceSample++;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _DestSample$6[ebp]
  00093	8b 4d f8	 mov	 ecx, DWORD PTR _SourceSample$5[ebp]
  00096	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00099	66 89 10	 mov	 WORD PTR [eax], dx
  0009c	8b 45 fc	 mov	 eax, DWORD PTR _DestSample$6[ebp]
  0009f	83 c0 02	 add	 eax, 2
  000a2	89 45 fc	 mov	 DWORD PTR _DestSample$6[ebp], eax
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _SourceSample$5[ebp]
  000a8	83 c1 02	 add	 ecx, 2
  000ab	89 4d f8	 mov	 DWORD PTR _SourceSample$5[ebp], ecx

; 437  :             ++SoundOutput->RunningSampleIndex;

  000ae	8b 55 08	 mov	 edx, DWORD PTR _SoundOutput$[ebp]
  000b1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b4	83 c0 01	 add	 eax, 1
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _SoundOutput$[ebp]
  000ba	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 438  :         }

  000bd	eb a2		 jmp	 SHORT $LN2@win32FillS
$LN3@win32FillS:

; 439  : 
; 440  :         DWORD Region2SampleCount = Region2Size/SoundOutput->BytesPerSample;

  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _SoundOutput$[ebp]
  000c2	8b 45 ec	 mov	 eax, DWORD PTR _Region2Size$[ebp]
  000c5	33 d2		 xor	 edx, edx
  000c7	f7 71 08	 div	 DWORD PTR [ecx+8]
  000ca	89 45 d8	 mov	 DWORD PTR _Region2SampleCount$1[ebp], eax

; 441  :         DestSample = (int16 *)Region2;

  000cd	8b 55 e8	 mov	 edx, DWORD PTR _Region2$[ebp]
  000d0	89 55 fc	 mov	 DWORD PTR _DestSample$6[ebp], edx

; 442  :         for(DWORD SampleIndex = 0; SampleIndex < Region2SampleCount; ++SampleIndex) {

  000d3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _SampleIndex$3[ebp], 0
  000da	eb 09		 jmp	 SHORT $LN7@win32FillS
$LN5@win32FillS:
  000dc	8b 45 f0	 mov	 eax, DWORD PTR _SampleIndex$3[ebp]
  000df	83 c0 01	 add	 eax, 1
  000e2	89 45 f0	 mov	 DWORD PTR _SampleIndex$3[ebp], eax
$LN7@win32FillS:
  000e5	8b 4d f0	 mov	 ecx, DWORD PTR _SampleIndex$3[ebp]
  000e8	3b 4d d8	 cmp	 ecx, DWORD PTR _Region2SampleCount$1[ebp]
  000eb	73 4d		 jae	 SHORT $LN6@win32FillS

; 443  :             *DestSample++ = *SourceSample++;

  000ed	8b 55 fc	 mov	 edx, DWORD PTR _DestSample$6[ebp]
  000f0	8b 45 f8	 mov	 eax, DWORD PTR _SourceSample$5[ebp]
  000f3	66 8b 08	 mov	 cx, WORD PTR [eax]
  000f6	66 89 0a	 mov	 WORD PTR [edx], cx
  000f9	8b 55 fc	 mov	 edx, DWORD PTR _DestSample$6[ebp]
  000fc	83 c2 02	 add	 edx, 2
  000ff	89 55 fc	 mov	 DWORD PTR _DestSample$6[ebp], edx
  00102	8b 45 f8	 mov	 eax, DWORD PTR _SourceSample$5[ebp]
  00105	83 c0 02	 add	 eax, 2
  00108	89 45 f8	 mov	 DWORD PTR _SourceSample$5[ebp], eax

; 444  :             *DestSample++ = *SourceSample++;

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _DestSample$6[ebp]
  0010e	8b 55 f8	 mov	 edx, DWORD PTR _SourceSample$5[ebp]
  00111	66 8b 02	 mov	 ax, WORD PTR [edx]
  00114	66 89 01	 mov	 WORD PTR [ecx], ax
  00117	8b 4d fc	 mov	 ecx, DWORD PTR _DestSample$6[ebp]
  0011a	83 c1 02	 add	 ecx, 2
  0011d	89 4d fc	 mov	 DWORD PTR _DestSample$6[ebp], ecx
  00120	8b 55 f8	 mov	 edx, DWORD PTR _SourceSample$5[ebp]
  00123	83 c2 02	 add	 edx, 2
  00126	89 55 f8	 mov	 DWORD PTR _SourceSample$5[ebp], edx

; 445  :             ++SoundOutput->RunningSampleIndex;

  00129	8b 45 08	 mov	 eax, DWORD PTR _SoundOutput$[ebp]
  0012c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012f	83 c1 01	 add	 ecx, 1
  00132	8b 55 08	 mov	 edx, DWORD PTR _SoundOutput$[ebp]
  00135	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 446  :         }

  00138	eb a2		 jmp	 SHORT $LN5@win32FillS
$LN6@win32FillS:

; 447  : 
; 448  :         GlobalSecondaryBuffer->Unlock(Region1, Region1Size, Region2, Region2Size);

  0013a	8b 45 ec	 mov	 eax, DWORD PTR _Region2Size$[ebp]
  0013d	50		 push	 eax
  0013e	8b 4d e8	 mov	 ecx, DWORD PTR _Region2$[ebp]
  00141	51		 push	 ecx
  00142	8b 55 e4	 mov	 edx, DWORD PTR _Region1Size$[ebp]
  00145	52		 push	 edx
  00146	8b 45 e0	 mov	 eax, DWORD PTR _Region1$[ebp]
  00149	50		 push	 eax
  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  00150	8b 11		 mov	 edx, DWORD PTR [ecx]
  00152	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  00157	50		 push	 eax
  00158	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  0015b	ff d1		 call	 ecx
$LN1@win32FillS:

; 449  :     }
; 450  : }

  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c3		 ret	 0
?win32FillSoundBuffer@@YAXPAUwin32_sound_output@@KKPAUgame_sound_output_buffer@@@Z ENDP ; win32FillSoundBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_Region1$ = -28						; size = 4
_Region1Size$ = -24					; size = 4
_Region2$ = -20						; size = 4
_Region2Size$ = -16					; size = 4
_ByteIndex$1 = -12					; size = 4
_ByteIndex$2 = -8					; size = 4
_DestSample$3 = -4					; size = 4
_SoundOutput$ = 8					; size = 4
?win32ClearBuffer@@YAXPAUwin32_sound_output@@@Z PROC	; win32ClearBuffer

; 391  : win32ClearBuffer(win32_sound_output *SoundOutput) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 392  :     VOID *Region1;
; 393  :     DWORD Region1Size;
; 394  :     VOID *Region2;
; 395  :     DWORD Region2Size;
; 396  :     if(SUCCEEDED(GlobalSecondaryBuffer->Lock(

  00006	6a 00		 push	 0
  00008	8d 45 f0	 lea	 eax, DWORD PTR _Region2Size$[ebp]
  0000b	50		 push	 eax
  0000c	8d 4d ec	 lea	 ecx, DWORD PTR _Region2$[ebp]
  0000f	51		 push	 ecx
  00010	8d 55 e8	 lea	 edx, DWORD PTR _Region1Size$[ebp]
  00013	52		 push	 edx
  00014	8d 45 e4	 lea	 eax, DWORD PTR _Region1$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _SoundOutput$[ebp]
  0001b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0001e	52		 push	 edx
  0001f	6a 00		 push	 0
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  0002e	52		 push	 edx
  0002f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00032	ff d0		 call	 eax
  00034	85 c0		 test	 eax, eax
  00036	0f 8c 85 00 00
	00		 jl	 $LN1@win32Clear

; 397  :         0, SoundOutput->SecondaryBufferSize,
; 398  :         &Region1, &Region1Size,
; 399  :         &Region2, &Region2Size,
; 400  :         0
; 401  :     ))) {
; 402  :         // TODO Assert that Region1Size/Region2Sizse is valid
; 403  :         uint8 *DestSample = (uint8 *)Region1;

  0003c	8b 4d e4	 mov	 ecx, DWORD PTR _Region1$[ebp]
  0003f	89 4d fc	 mov	 DWORD PTR _DestSample$3[ebp], ecx

; 404  :         for(DWORD ByteIndex = 0; ByteIndex < Region1Size; ++ByteIndex) {

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ByteIndex$2[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN4@win32Clear
$LN2@win32Clear:
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _ByteIndex$2[ebp]
  0004e	83 c2 01	 add	 edx, 1
  00051	89 55 f8	 mov	 DWORD PTR _ByteIndex$2[ebp], edx
$LN4@win32Clear:
  00054	8b 45 f8	 mov	 eax, DWORD PTR _ByteIndex$2[ebp]
  00057	3b 45 e8	 cmp	 eax, DWORD PTR _Region1Size$[ebp]
  0005a	73 11		 jae	 SHORT $LN3@win32Clear

; 405  :             *DestSample++ = 0;

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _DestSample$3[ebp]
  0005f	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00062	8b 55 fc	 mov	 edx, DWORD PTR _DestSample$3[ebp]
  00065	83 c2 01	 add	 edx, 1
  00068	89 55 fc	 mov	 DWORD PTR _DestSample$3[ebp], edx

; 406  :         }

  0006b	eb de		 jmp	 SHORT $LN2@win32Clear
$LN3@win32Clear:

; 407  : 
; 408  :         DestSample = (uint8 *)Region2;

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _Region2$[ebp]
  00070	89 45 fc	 mov	 DWORD PTR _DestSample$3[ebp], eax

; 409  :         for(DWORD ByteIndex = 0; ByteIndex < Region2Size; ++ByteIndex) {

  00073	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ByteIndex$1[ebp], 0
  0007a	eb 09		 jmp	 SHORT $LN7@win32Clear
$LN5@win32Clear:
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR _ByteIndex$1[ebp]
  0007f	83 c1 01	 add	 ecx, 1
  00082	89 4d f4	 mov	 DWORD PTR _ByteIndex$1[ebp], ecx
$LN7@win32Clear:
  00085	8b 55 f4	 mov	 edx, DWORD PTR _ByteIndex$1[ebp]
  00088	3b 55 f0	 cmp	 edx, DWORD PTR _Region2Size$[ebp]
  0008b	73 11		 jae	 SHORT $LN6@win32Clear

; 410  :             *DestSample++ = 0;

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _DestSample$3[ebp]
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _DestSample$3[ebp]
  00096	83 c1 01	 add	 ecx, 1
  00099	89 4d fc	 mov	 DWORD PTR _DestSample$3[ebp], ecx

; 411  :         }

  0009c	eb de		 jmp	 SHORT $LN5@win32Clear
$LN6@win32Clear:

; 412  : 
; 413  :         GlobalSecondaryBuffer->Unlock(Region1, Region1Size, Region2, Region2Size);

  0009e	8b 55 f0	 mov	 edx, DWORD PTR _Region2Size$[ebp]
  000a1	52		 push	 edx
  000a2	8b 45 ec	 mov	 eax, DWORD PTR _Region2$[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d e8	 mov	 ecx, DWORD PTR _Region1Size$[ebp]
  000a9	51		 push	 ecx
  000aa	8b 55 e4	 mov	 edx, DWORD PTR _Region1$[ebp]
  000ad	52		 push	 edx
  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  000bb	52		 push	 edx
  000bc	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  000bf	ff d0		 call	 eax
$LN1@win32Clear:

; 414  :     }
; 415  : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?win32ClearBuffer@@YAXPAUwin32_sound_output@@@Z ENDP	; win32ClearBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
$T1 = -96						; size = 8
_Dimension$2 = -88					; size = 8
_DeviceContext$3 = -80					; size = 4
_Result$ = -76						; size = 4
tv64 = -72						; size = 4
_Paint$4 = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
_Message$ = 12						; size = 4
_WParam$ = 16						; size = 4
_LParam$ = 20						; size = 4
?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z PROC	; Win32MainWindowCallback

; 343  : ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 344  :     LRESULT Result = 0;

  00010	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 0

; 345  : 
; 346  :     switch(Message)

  00017	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  0001a	89 45 b8	 mov	 DWORD PTR tv64[ebp], eax
  0001d	83 7d b8 10	 cmp	 DWORD PTR tv64[ebp], 16	; 00000010H
  00021	77 1d		 ja	 SHORT $LN13@Win32MainW
  00023	83 7d b8 10	 cmp	 DWORD PTR tv64[ebp], 16	; 00000010H
  00027	74 43		 je	 SHORT $LN5@Win32MainW
  00029	83 7d b8 02	 cmp	 DWORD PTR tv64[ebp], 2
  0002d	74 5c		 je	 SHORT $LN7@Win32MainW
  0002f	83 7d b8 05	 cmp	 DWORD PTR tv64[ebp], 5
  00033	74 32		 je	 SHORT $LN4@Win32MainW
  00035	83 7d b8 0f	 cmp	 DWORD PTR tv64[ebp], 15	; 0000000fH
  00039	74 74		 je	 SHORT $LN10@Win32MainW
  0003b	e9 d2 00 00 00	 jmp	 $LN11@Win32MainW
$LN13@Win32MainW:
  00040	8b 4d b8	 mov	 ecx, DWORD PTR tv64[ebp]
  00043	83 e9 1c	 sub	 ecx, 28			; 0000001cH
  00046	89 4d b8	 mov	 DWORD PTR tv64[ebp], ecx
  00049	81 7d b8 e9 00
	00 00		 cmp	 DWORD PTR tv64[ebp], 233 ; 000000e9H
  00050	0f 87 bc 00 00
	00		 ja	 $LN11@Win32MainW
  00056	8b 55 b8	 mov	 edx, DWORD PTR tv64[ebp]
  00059	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN14@Win32MainW[edx]
  00060	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN15@Win32MainW[eax*4]
$LN4@Win32MainW:

; 347  :     {
; 348  :         case WM_SIZE: {
; 349  :         } break;

  00067	e9 bf 00 00 00	 jmp	 $LN2@Win32MainW
$LN5@Win32MainW:

; 350  : 
; 351  :         case WM_CLOSE: {
; 352  :             // TODO Handle this with a message to the user?
; 353  :             GlobalRunning = false;

  0006c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 354  :         } break;

  00076	e9 b0 00 00 00	 jmp	 $LN2@Win32MainW
$LN6@Win32MainW:

; 355  : 
; 356  :         case WM_ACTIVATEAPP: {
; 357  :             OutputDebugStringA("WM_ACTIVATEAPP\n");

  0007b	68 00 00 00 00	 push	 OFFSET $SG87779
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 358  :         } break;

  00086	e9 a0 00 00 00	 jmp	 $LN2@Win32MainW
$LN7@Win32MainW:

; 359  : 
; 360  :         case WM_DESTROY: {
; 361  :             // TODO Handle this as an error - recreate window?
; 362  :             GlobalRunning = false;

  0008b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 0

; 363  :         } break;

  00095	e9 91 00 00 00	 jmp	 $LN2@Win32MainW
$LN8@Win32MainW:

; 364  : 
; 365  :         case WM_SYSKEYDOWN: 
; 366  :         case WM_SYSKEYUP:
; 367  :         case WM_KEYDOWN:
; 368  :         case WM_KEYUP: {
; 369  :             Assert(!"Keyboard input came in through a non-dispatch message!");

  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET $SG87783
  0009f	85 c9		 test	 ecx, ecx
  000a1	74 0a		 je	 SHORT $LN9@Win32MainW
  000a3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ds:0, 0
$LN9@Win32MainW:

; 370  :         } break;

  000ad	eb 7c		 jmp	 SHORT $LN2@Win32MainW
$LN10@Win32MainW:

; 371  : 
; 372  :         case WM_PAINT: {
; 373  :             OutputDebugStringA("WM_PAINT\n");

  000af	68 00 00 00 00	 push	 OFFSET $SG87785
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 374  :             PAINTSTRUCT Paint;
; 375  :             HDC DeviceContext = BeginPaint(Window, &Paint);

  000ba	8d 55 bc	 lea	 edx, DWORD PTR _Paint$4[ebp]
  000bd	52		 push	 edx
  000be	8b 45 08	 mov	 eax, DWORD PTR _Window$[ebp]
  000c1	50		 push	 eax
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BeginPaint@8
  000c8	89 45 b0	 mov	 DWORD PTR _DeviceContext$3[ebp], eax

; 376  :             win32_window_dimension Dimension = Win32GetWindowDimension(Window);

  000cb	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 ?Win32GetWindowDimension@@YA?AUwin32_window_dimension@@PAUHWND__@@@Z ; Win32GetWindowDimension
  000d4	83 c4 04	 add	 esp, 4
  000d7	89 45 a0	 mov	 DWORD PTR $T1[ebp], eax
  000da	89 55 a4	 mov	 DWORD PTR $T1[ebp+4], edx
  000dd	8b 55 a0	 mov	 edx, DWORD PTR $T1[ebp]
  000e0	89 55 a8	 mov	 DWORD PTR _Dimension$2[ebp], edx
  000e3	8b 45 a4	 mov	 eax, DWORD PTR $T1[ebp+4]
  000e6	89 45 ac	 mov	 DWORD PTR _Dimension$2[ebp+4], eax

; 377  :             Win32DisplayBufferInWindow(&GlobalBackbuffer, DeviceContext, Dimension.Width, Dimension.Height);

  000e9	8b 4d ac	 mov	 ecx, DWORD PTR _Dimension$2[ebp+4]
  000ec	51		 push	 ecx
  000ed	8b 55 a8	 mov	 edx, DWORD PTR _Dimension$2[ebp]
  000f0	52		 push	 edx
  000f1	8b 45 b0	 mov	 eax, DWORD PTR _DeviceContext$3[ebp]
  000f4	50		 push	 eax
  000f5	68 00 00 00 00	 push	 OFFSET ?GlobalBackbuffer@@3Uwin32_offscreen_buffer@@A
  000fa	e8 00 00 00 00	 call	 ?Win32DisplayBufferInWindow@@YAXPAUwin32_offscreen_buffer@@PAUHDC__@@HH@Z ; Win32DisplayBufferInWindow
  000ff	83 c4 10	 add	 esp, 16			; 00000010H

; 378  :             EndPaint(Window, &Paint);

  00102	8d 4d bc	 lea	 ecx, DWORD PTR _Paint$4[ebp]
  00105	51		 push	 ecx
  00106	8b 55 08	 mov	 edx, DWORD PTR _Window$[ebp]
  00109	52		 push	 edx
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndPaint@8

; 379  :         } break;

  00110	eb 19		 jmp	 SHORT $LN2@Win32MainW
$LN11@Win32MainW:

; 380  : 
; 381  :         default: {
; 382  :             Result = DefWindowProcA(Window, Message, WParam, LParam);

  00112	8b 45 14	 mov	 eax, DWORD PTR _LParam$[ebp]
  00115	50		 push	 eax
  00116	8b 4d 10	 mov	 ecx, DWORD PTR _WParam$[ebp]
  00119	51		 push	 ecx
  0011a	8b 55 0c	 mov	 edx, DWORD PTR _Message$[ebp]
  0011d	52		 push	 edx
  0011e	8b 45 08	 mov	 eax, DWORD PTR _Window$[ebp]
  00121	50		 push	 eax
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  00128	89 45 b4	 mov	 DWORD PTR _Result$[ebp], eax
$LN2@Win32MainW:

; 383  :         } break;
; 384  :     }
; 385  : 
; 386  :     return(Result);

  0012b	8b 45 b4	 mov	 eax, DWORD PTR _Result$[ebp]

; 387  : } 

  0012e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00131	33 cd		 xor	 ecx, ebp
  00133	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c2 10 00	 ret	 16			; 00000010H
  0013e	66 90		 npad	 2
$LN15@Win32MainW:
  00140	00 00 00 00	 DD	 $LN6@Win32MainW
  00144	00 00 00 00	 DD	 $LN8@Win32MainW
  00148	00 00 00 00	 DD	 $LN11@Win32MainW
$LN14@Win32MainW:
  0014c	00		 DB	 0
  0014d	02		 DB	 2
  0014e	02		 DB	 2
  0014f	02		 DB	 2
  00150	02		 DB	 2
  00151	02		 DB	 2
  00152	02		 DB	 2
  00153	02		 DB	 2
  00154	02		 DB	 2
  00155	02		 DB	 2
  00156	02		 DB	 2
  00157	02		 DB	 2
  00158	02		 DB	 2
  00159	02		 DB	 2
  0015a	02		 DB	 2
  0015b	02		 DB	 2
  0015c	02		 DB	 2
  0015d	02		 DB	 2
  0015e	02		 DB	 2
  0015f	02		 DB	 2
  00160	02		 DB	 2
  00161	02		 DB	 2
  00162	02		 DB	 2
  00163	02		 DB	 2
  00164	02		 DB	 2
  00165	02		 DB	 2
  00166	02		 DB	 2
  00167	02		 DB	 2
  00168	02		 DB	 2
  00169	02		 DB	 2
  0016a	02		 DB	 2
  0016b	02		 DB	 2
  0016c	02		 DB	 2
  0016d	02		 DB	 2
  0016e	02		 DB	 2
  0016f	02		 DB	 2
  00170	02		 DB	 2
  00171	02		 DB	 2
  00172	02		 DB	 2
  00173	02		 DB	 2
  00174	02		 DB	 2
  00175	02		 DB	 2
  00176	02		 DB	 2
  00177	02		 DB	 2
  00178	02		 DB	 2
  00179	02		 DB	 2
  0017a	02		 DB	 2
  0017b	02		 DB	 2
  0017c	02		 DB	 2
  0017d	02		 DB	 2
  0017e	02		 DB	 2
  0017f	02		 DB	 2
  00180	02		 DB	 2
  00181	02		 DB	 2
  00182	02		 DB	 2
  00183	02		 DB	 2
  00184	02		 DB	 2
  00185	02		 DB	 2
  00186	02		 DB	 2
  00187	02		 DB	 2
  00188	02		 DB	 2
  00189	02		 DB	 2
  0018a	02		 DB	 2
  0018b	02		 DB	 2
  0018c	02		 DB	 2
  0018d	02		 DB	 2
  0018e	02		 DB	 2
  0018f	02		 DB	 2
  00190	02		 DB	 2
  00191	02		 DB	 2
  00192	02		 DB	 2
  00193	02		 DB	 2
  00194	02		 DB	 2
  00195	02		 DB	 2
  00196	02		 DB	 2
  00197	02		 DB	 2
  00198	02		 DB	 2
  00199	02		 DB	 2
  0019a	02		 DB	 2
  0019b	02		 DB	 2
  0019c	02		 DB	 2
  0019d	02		 DB	 2
  0019e	02		 DB	 2
  0019f	02		 DB	 2
  001a0	02		 DB	 2
  001a1	02		 DB	 2
  001a2	02		 DB	 2
  001a3	02		 DB	 2
  001a4	02		 DB	 2
  001a5	02		 DB	 2
  001a6	02		 DB	 2
  001a7	02		 DB	 2
  001a8	02		 DB	 2
  001a9	02		 DB	 2
  001aa	02		 DB	 2
  001ab	02		 DB	 2
  001ac	02		 DB	 2
  001ad	02		 DB	 2
  001ae	02		 DB	 2
  001af	02		 DB	 2
  001b0	02		 DB	 2
  001b1	02		 DB	 2
  001b2	02		 DB	 2
  001b3	02		 DB	 2
  001b4	02		 DB	 2
  001b5	02		 DB	 2
  001b6	02		 DB	 2
  001b7	02		 DB	 2
  001b8	02		 DB	 2
  001b9	02		 DB	 2
  001ba	02		 DB	 2
  001bb	02		 DB	 2
  001bc	02		 DB	 2
  001bd	02		 DB	 2
  001be	02		 DB	 2
  001bf	02		 DB	 2
  001c0	02		 DB	 2
  001c1	02		 DB	 2
  001c2	02		 DB	 2
  001c3	02		 DB	 2
  001c4	02		 DB	 2
  001c5	02		 DB	 2
  001c6	02		 DB	 2
  001c7	02		 DB	 2
  001c8	02		 DB	 2
  001c9	02		 DB	 2
  001ca	02		 DB	 2
  001cb	02		 DB	 2
  001cc	02		 DB	 2
  001cd	02		 DB	 2
  001ce	02		 DB	 2
  001cf	02		 DB	 2
  001d0	02		 DB	 2
  001d1	02		 DB	 2
  001d2	02		 DB	 2
  001d3	02		 DB	 2
  001d4	02		 DB	 2
  001d5	02		 DB	 2
  001d6	02		 DB	 2
  001d7	02		 DB	 2
  001d8	02		 DB	 2
  001d9	02		 DB	 2
  001da	02		 DB	 2
  001db	02		 DB	 2
  001dc	02		 DB	 2
  001dd	02		 DB	 2
  001de	02		 DB	 2
  001df	02		 DB	 2
  001e0	02		 DB	 2
  001e1	02		 DB	 2
  001e2	02		 DB	 2
  001e3	02		 DB	 2
  001e4	02		 DB	 2
  001e5	02		 DB	 2
  001e6	02		 DB	 2
  001e7	02		 DB	 2
  001e8	02		 DB	 2
  001e9	02		 DB	 2
  001ea	02		 DB	 2
  001eb	02		 DB	 2
  001ec	02		 DB	 2
  001ed	02		 DB	 2
  001ee	02		 DB	 2
  001ef	02		 DB	 2
  001f0	02		 DB	 2
  001f1	02		 DB	 2
  001f2	02		 DB	 2
  001f3	02		 DB	 2
  001f4	02		 DB	 2
  001f5	02		 DB	 2
  001f6	02		 DB	 2
  001f7	02		 DB	 2
  001f8	02		 DB	 2
  001f9	02		 DB	 2
  001fa	02		 DB	 2
  001fb	02		 DB	 2
  001fc	02		 DB	 2
  001fd	02		 DB	 2
  001fe	02		 DB	 2
  001ff	02		 DB	 2
  00200	02		 DB	 2
  00201	02		 DB	 2
  00202	02		 DB	 2
  00203	02		 DB	 2
  00204	02		 DB	 2
  00205	02		 DB	 2
  00206	02		 DB	 2
  00207	02		 DB	 2
  00208	02		 DB	 2
  00209	02		 DB	 2
  0020a	02		 DB	 2
  0020b	02		 DB	 2
  0020c	02		 DB	 2
  0020d	02		 DB	 2
  0020e	02		 DB	 2
  0020f	02		 DB	 2
  00210	02		 DB	 2
  00211	02		 DB	 2
  00212	02		 DB	 2
  00213	02		 DB	 2
  00214	02		 DB	 2
  00215	02		 DB	 2
  00216	02		 DB	 2
  00217	02		 DB	 2
  00218	02		 DB	 2
  00219	02		 DB	 2
  0021a	02		 DB	 2
  0021b	02		 DB	 2
  0021c	02		 DB	 2
  0021d	02		 DB	 2
  0021e	02		 DB	 2
  0021f	02		 DB	 2
  00220	02		 DB	 2
  00221	02		 DB	 2
  00222	02		 DB	 2
  00223	02		 DB	 2
  00224	02		 DB	 2
  00225	02		 DB	 2
  00226	02		 DB	 2
  00227	02		 DB	 2
  00228	02		 DB	 2
  00229	02		 DB	 2
  0022a	02		 DB	 2
  0022b	02		 DB	 2
  0022c	02		 DB	 2
  0022d	02		 DB	 2
  0022e	02		 DB	 2
  0022f	02		 DB	 2
  00230	01		 DB	 1
  00231	01		 DB	 1
  00232	02		 DB	 2
  00233	02		 DB	 2
  00234	01		 DB	 1
  00235	01		 DB	 1
?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z ENDP	; Win32MainWindowCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_Buffer$ = 8						; size = 4
_DeviceContext$ = 12					; size = 4
_WindowWidth$ = 16					; size = 4
_WindowHeight$ = 20					; size = 4
?Win32DisplayBufferInWindow@@YAXPAUwin32_offscreen_buffer@@PAUHDC__@@HH@Z PROC ; Win32DisplayBufferInWindow

; 323  : ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 324  :     // TODO aspect ration correction
; 325  :     StretchDIBits(

  00003	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00008	6a 00		 push	 0
  0000a	8b 45 08	 mov	 eax, DWORD PTR _Buffer$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  00011	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _Buffer$[ebp]
  00018	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _Buffer$[ebp]
  0001f	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00022	50		 push	 eax
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	8b 4d 14	 mov	 ecx, DWORD PTR _WindowHeight$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 10	 mov	 edx, DWORD PTR _WindowWidth$[ebp]
  0002e	52		 push	 edx
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	8b 45 0c	 mov	 eax, DWORD PTR _DeviceContext$[ebp]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52

; 326  :         DeviceContext,
; 327  :         0, 0, WindowWidth, WindowHeight,
; 328  :         0, 0, Buffer->Width, Buffer->Height,
; 329  :         Buffer->Memory,
; 330  :         &Buffer->Info,
; 331  :         DIB_RGB_COLORS, SRCCOPY
; 332  :     );
; 333  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?Win32DisplayBufferInWindow@@YAXPAUwin32_offscreen_buffer@@PAUHDC__@@HH@Z ENDP ; Win32DisplayBufferInWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_BitmapMemorySize$ = -4					; size = 4
_Buffer$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
?Win32ResizeDIBSection@@YAXPAUwin32_offscreen_buffer@@HH@Z PROC ; Win32ResizeDIBSection

; 288  : Win32ResizeDIBSection(win32_offscreen_buffer *Buffer, int Width, int Height) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 289  :     // TODO Bulletproof this
; 290  :     // Maybe don't free first, free after, then free first if that fails
; 291  : 
; 292  :     if(Buffer->Memory) {

  00004	8b 45 08	 mov	 eax, DWORD PTR _Buffer$[ebp]
  00007	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0000b	74 14		 je	 SHORT $LN2@Win32Resiz

; 293  :         VirtualFree(Buffer->Memory, 0, MEM_RELEASE);

  0000d	68 00 80 00 00	 push	 32768			; 00008000H
  00012	6a 00		 push	 0
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  00017	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0001a	52		 push	 edx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFree@12
$LN2@Win32Resiz:

; 294  :     }
; 295  : 
; 296  :     Buffer->Width = Width;

  00021	8b 45 08	 mov	 eax, DWORD PTR _Buffer$[ebp]
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR _Width$[ebp]
  00027	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 297  :     Buffer->Height = Height;

  0002a	8b 55 08	 mov	 edx, DWORD PTR _Buffer$[ebp]
  0002d	8b 45 10	 mov	 eax, DWORD PTR _Height$[ebp]
  00030	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 298  :     Buffer->BytesPerPixel = 4;

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  00036	c7 41 3c 04 00
	00 00		 mov	 DWORD PTR [ecx+60], 4

; 299  : 
; 300  :     Buffer->Info.bmiHeader.biSize = sizeof(Buffer->Info.bmiHeader);

  0003d	8b 55 08	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00040	c7 02 28 00 00
	00		 mov	 DWORD PTR [edx], 40	; 00000028H

; 301  :     Buffer->Info.bmiHeader.biWidth = Buffer->Width;

  00046	8b 45 08	 mov	 eax, DWORD PTR _Buffer$[ebp]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  0004c	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0004f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 302  :     Buffer->Info.bmiHeader.biHeight = -Buffer->Height;

  00052	8b 45 08	 mov	 eax, DWORD PTR _Buffer$[ebp]
  00055	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00058	f7 d9		 neg	 ecx
  0005a	8b 55 08	 mov	 edx, DWORD PTR _Buffer$[ebp]
  0005d	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 303  :     Buffer->Info.bmiHeader.biPlanes = 1;

  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  00068	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 304  :     Buffer->Info.bmiHeader.biBitCount = 32;

  0006c	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00071	8b 45 08	 mov	 eax, DWORD PTR _Buffer$[ebp]
  00074	66 89 50 0e	 mov	 WORD PTR [eax+14], dx

; 305  :     Buffer->Info.bmiHeader.biCompression = BI_RGB;

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  0007b	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 306  : 
; 307  :     // NOTE Thanks Chris Hecker for clarifying StretchDIBits/BitBlt
; 308  :     int BitmapMemorySize = (Buffer->Width*Buffer->Height)*Buffer->BytesPerPixel;

  00082	8b 55 08	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00085	8b 45 08	 mov	 eax, DWORD PTR _Buffer$[ebp]
  00088	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  0008b	0f af 48 34	 imul	 ecx, DWORD PTR [eax+52]
  0008f	8b 55 08	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00092	0f af 4a 3c	 imul	 ecx, DWORD PTR [edx+60]
  00096	89 4d fc	 mov	 DWORD PTR _BitmapMemorySize$[ebp], ecx

; 309  :     Buffer->Memory = VirtualAlloc(0, BitmapMemorySize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  00099	6a 04		 push	 4
  0009b	68 00 30 00 00	 push	 12288			; 00003000H
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _BitmapMemorySize$[ebp]
  000a3	50		 push	 eax
  000a4	6a 00		 push	 0
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  000af	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 310  : 
; 311  :     // TODO probably clear to black
; 312  : 
; 313  :     Buffer->Pitch = Width*Buffer->BytesPerPixel;

  000b2	8b 55 08	 mov	 edx, DWORD PTR _Buffer$[ebp]
  000b5	8b 45 0c	 mov	 eax, DWORD PTR _Width$[ebp]
  000b8	0f af 42 3c	 imul	 eax, DWORD PTR [edx+60]
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  000bf	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 314  : }

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
?Win32ResizeDIBSection@@YAXPAUwin32_offscreen_buffer@@HH@Z ENDP ; Win32ResizeDIBSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_Result$ = -28						; size = 8
_ClientRect$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
?Win32GetWindowDimension@@YA?AUwin32_window_dimension@@PAUHWND__@@@Z PROC ; Win32GetWindowDimension

; 271  : internal win32_window_dimension Win32GetWindowDimension(HWND Window) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 272  :     win32_window_dimension Result;
; 273  : 
; 274  :     RECT ClientRect;
; 275  :     GetClientRect(Window, &ClientRect);

  00010	8d 45 ec	 lea	 eax, DWORD PTR _ClientRect$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  00017	51		 push	 ecx
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 276  :     Result.Width = ClientRect.right - ClientRect.left;

  0001e	8b 55 f4	 mov	 edx, DWORD PTR _ClientRect$[ebp+8]
  00021	2b 55 ec	 sub	 edx, DWORD PTR _ClientRect$[ebp]
  00024	89 55 e4	 mov	 DWORD PTR _Result$[ebp], edx

; 277  :     Result.Height = ClientRect.bottom - ClientRect.top;

  00027	8b 45 f8	 mov	 eax, DWORD PTR _ClientRect$[ebp+12]
  0002a	2b 45 f0	 sub	 eax, DWORD PTR _ClientRect$[ebp+4]
  0002d	89 45 e8	 mov	 DWORD PTR _Result$[ebp+4], eax

; 278  : 
; 279  :     return(Result);

  00030	8b 45 e4	 mov	 eax, DWORD PTR _Result$[ebp]
  00033	8b 55 e8	 mov	 edx, DWORD PTR _Result$[ebp+4]

; 280  : }

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00039	33 cd		 xor	 ecx, ebp
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?Win32GetWindowDimension@@YA?AUwin32_window_dimension@@PAUHWND__@@@Z ENDP ; Win32GetWindowDimension
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_Error$1 = -120						; size = 4
_Error$2 = -116						; size = 4
_DirectSoundCreate$3 = -112				; size = 4
_DSoundLibrary$ = -108					; size = 4
_PrimaryBuffer$4 = -104					; size = 4
_DirectSound$5 = -100					; size = 4
_BufferDescription$6 = -96				; size = 36
_BufferDescription$7 = -60				; size = 36
_WaveFormat$8 = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_Window$ = 8						; size = 4
_SamplesPerSecond$ = 12					; size = 4
_BufferSize$ = 16					; size = 4
?Win32InitDSound@@YAXPAUHWND__@@HH@Z PROC		; Win32InitDSound

; 210  : Win32InitDSound(HWND Window, int32 SamplesPerSecond, int32 BufferSize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 211  :     HMODULE DSoundLibrary = LoadLibraryA("dsound.dll");

  00010	68 00 00 00 00	 push	 OFFSET $SG87729
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0001b	89 45 94	 mov	 DWORD PTR _DSoundLibrary$[ebp], eax

; 212  : 
; 213  :     if(DSoundLibrary) {

  0001e	83 7d 94 00	 cmp	 DWORD PTR _DSoundLibrary$[ebp], 0
  00022	0f 84 7c 01 00
	00		 je	 $LN1@Win32InitD

; 214  :         direct_sound_create *DirectSoundCreate = (direct_sound_create *)GetProcAddress(DSoundLibrary, "DirectSoundCreate");

  00028	68 00 00 00 00	 push	 OFFSET $SG87731
  0002d	8b 45 94	 mov	 eax, DWORD PTR _DSoundLibrary$[ebp]
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00037	89 45 90	 mov	 DWORD PTR _DirectSoundCreate$3[ebp], eax

; 215  :         // TODO double-check that this works on XP -- 7 or 8?
; 216  :         LPDIRECTSOUND DirectSound;
; 217  :         if(DirectSoundCreate && SUCCEEDED(DirectSoundCreate(0, &DirectSound, 0))) {

  0003a	83 7d 90 00	 cmp	 DWORD PTR _DirectSoundCreate$3[ebp], 0
  0003e	0f 84 60 01 00
	00		 je	 $LN1@Win32InitD
  00044	6a 00		 push	 0
  00046	8d 4d 9c	 lea	 ecx, DWORD PTR _DirectSound$5[ebp]
  00049	51		 push	 ecx
  0004a	6a 00		 push	 0
  0004c	ff 55 90	 call	 DWORD PTR _DirectSoundCreate$3[ebp]
  0004f	85 c0		 test	 eax, eax
  00051	0f 8c 4d 01 00
	00		 jl	 $LN1@Win32InitD

; 218  :             WAVEFORMATEX WaveFormat = {};

  00057	33 d2		 xor	 edx, edx
  00059	89 55 e8	 mov	 DWORD PTR _WaveFormat$8[ebp], edx
  0005c	89 55 ec	 mov	 DWORD PTR _WaveFormat$8[ebp+4], edx
  0005f	89 55 f0	 mov	 DWORD PTR _WaveFormat$8[ebp+8], edx
  00062	89 55 f4	 mov	 DWORD PTR _WaveFormat$8[ebp+12], edx
  00065	66 89 55 f8	 mov	 WORD PTR _WaveFormat$8[ebp+16], dx

; 219  :             WaveFormat.wFormatTag = WAVE_FORMAT_PCM;

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	66 89 45 e8	 mov	 WORD PTR _WaveFormat$8[ebp], ax

; 220  :             WaveFormat.nChannels = 2;

  00072	b9 02 00 00 00	 mov	 ecx, 2
  00077	66 89 4d ea	 mov	 WORD PTR _WaveFormat$8[ebp+2], cx

; 221  :             WaveFormat.nSamplesPerSec = SamplesPerSecond;

  0007b	8b 55 0c	 mov	 edx, DWORD PTR _SamplesPerSecond$[ebp]
  0007e	89 55 ec	 mov	 DWORD PTR _WaveFormat$8[ebp+4], edx

; 222  :             WaveFormat.wBitsPerSample = 16;

  00081	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00086	66 89 45 f6	 mov	 WORD PTR _WaveFormat$8[ebp+14], ax

; 223  :             WaveFormat.nBlockAlign = (WaveFormat.nChannels*WaveFormat.wBitsPerSample) / 8;

  0008a	0f b7 45 ea	 movzx	 eax, WORD PTR _WaveFormat$8[ebp+2]
  0008e	0f b7 4d f6	 movzx	 ecx, WORD PTR _WaveFormat$8[ebp+14]
  00092	0f af c1	 imul	 eax, ecx
  00095	99		 cdq
  00096	83 e2 07	 and	 edx, 7
  00099	03 c2		 add	 eax, edx
  0009b	c1 f8 03	 sar	 eax, 3
  0009e	66 89 45 f4	 mov	 WORD PTR _WaveFormat$8[ebp+12], ax

; 224  :             WaveFormat.nAvgBytesPerSec = WaveFormat.nSamplesPerSec*WaveFormat.nBlockAlign;

  000a2	0f b7 55 f4	 movzx	 edx, WORD PTR _WaveFormat$8[ebp+12]
  000a6	0f af 55 ec	 imul	 edx, DWORD PTR _WaveFormat$8[ebp+4]
  000aa	89 55 f0	 mov	 DWORD PTR _WaveFormat$8[ebp+8], edx

; 225  :             WaveFormat.cbSize = 0;

  000ad	33 c0		 xor	 eax, eax
  000af	66 89 45 f8	 mov	 WORD PTR _WaveFormat$8[ebp+16], ax

; 226  : 
; 227  :             if(SUCCEEDED(DirectSound->SetCooperativeLevel(Window, DSSCL_PRIORITY))) {

  000b3	6a 02		 push	 2
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _Window$[ebp]
  000b8	51		 push	 ecx
  000b9	8b 55 9c	 mov	 edx, DWORD PTR _DirectSound$5[ebp]
  000bc	8b 02		 mov	 eax, DWORD PTR [edx]
  000be	8b 4d 9c	 mov	 ecx, DWORD PTR _DirectSound$5[ebp]
  000c1	51		 push	 ecx
  000c2	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000c5	ff d2		 call	 edx
  000c7	85 c0		 test	 eax, eax
  000c9	7c 71		 jl	 SHORT $LN6@Win32InitD

; 228  :                 DSBUFFERDESC BufferDescription = {0};

  000cb	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _BufferDescription$7[ebp], 0
  000d2	33 c0		 xor	 eax, eax
  000d4	89 45 c8	 mov	 DWORD PTR _BufferDescription$7[ebp+4], eax
  000d7	89 45 cc	 mov	 DWORD PTR _BufferDescription$7[ebp+8], eax
  000da	89 45 d0	 mov	 DWORD PTR _BufferDescription$7[ebp+12], eax
  000dd	89 45 d4	 mov	 DWORD PTR _BufferDescription$7[ebp+16], eax
  000e0	89 45 d8	 mov	 DWORD PTR _BufferDescription$7[ebp+20], eax
  000e3	89 45 dc	 mov	 DWORD PTR _BufferDescription$7[ebp+24], eax
  000e6	89 45 e0	 mov	 DWORD PTR _BufferDescription$7[ebp+28], eax
  000e9	89 45 e4	 mov	 DWORD PTR _BufferDescription$7[ebp+32], eax

; 229  :                 BufferDescription.dwSize = sizeof(BufferDescription);

  000ec	c7 45 c4 24 00
	00 00		 mov	 DWORD PTR _BufferDescription$7[ebp], 36 ; 00000024H

; 230  :                 BufferDescription.dwFlags = DSBCAPS_PRIMARYBUFFER;

  000f3	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _BufferDescription$7[ebp+4], 1

; 231  :                 // TODO DSBCAPS_GLOBALFOCUS?
; 232  : 
; 233  :                 LPDIRECTSOUNDBUFFER PrimaryBuffer;
; 234  : 
; 235  :                 if (SUCCEEDED(DirectSound->CreateSoundBuffer(&BufferDescription, &PrimaryBuffer, 0))) {

  000fa	6a 00		 push	 0
  000fc	8d 4d 98	 lea	 ecx, DWORD PTR _PrimaryBuffer$4[ebp]
  000ff	51		 push	 ecx
  00100	8d 55 c4	 lea	 edx, DWORD PTR _BufferDescription$7[ebp]
  00103	52		 push	 edx
  00104	8b 45 9c	 mov	 eax, DWORD PTR _DirectSound$5[ebp]
  00107	8b 08		 mov	 ecx, DWORD PTR [eax]
  00109	8b 55 9c	 mov	 edx, DWORD PTR _DirectSound$5[ebp]
  0010c	52		 push	 edx
  0010d	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00110	ff d0		 call	 eax
  00112	85 c0		 test	 eax, eax
  00114	7c 26		 jl	 SHORT $LN6@Win32InitD

; 236  :                     HRESULT Error = PrimaryBuffer->SetFormat(&WaveFormat);

  00116	8d 4d e8	 lea	 ecx, DWORD PTR _WaveFormat$8[ebp]
  00119	51		 push	 ecx
  0011a	8b 55 98	 mov	 edx, DWORD PTR _PrimaryBuffer$4[ebp]
  0011d	8b 02		 mov	 eax, DWORD PTR [edx]
  0011f	8b 4d 98	 mov	 ecx, DWORD PTR _PrimaryBuffer$4[ebp]
  00122	51		 push	 ecx
  00123	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00126	ff d2		 call	 edx
  00128	89 45 8c	 mov	 DWORD PTR _Error$2[ebp], eax

; 237  :                     if(SUCCEEDED(Error)) {

  0012b	83 7d 8c 00	 cmp	 DWORD PTR _Error$2[ebp], 0
  0012f	7c 0b		 jl	 SHORT $LN6@Win32InitD

; 238  :                         OutputDebugStringA("Primary buffer format was set.\n");

  00131	68 00 00 00 00	 push	 OFFSET $SG87740
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN6@Win32InitD:

; 239  :                     }
; 240  :                     else {
; 241  :                         // TODO Diagnostic
; 242  :                     }
; 243  :                 }
; 244  :                 else {
; 245  :                     // TODO Diagnostic
; 246  :                 }
; 247  :             }
; 248  :             else {
; 249  :                 // TODO Diagnostic
; 250  :             }
; 251  :             // TODO DSBCAPS_GETCURENTPOSITION2?
; 252  :             DSBUFFERDESC BufferDescription = {0};

  0013c	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _BufferDescription$6[ebp], 0
  00143	33 c0		 xor	 eax, eax
  00145	89 45 a4	 mov	 DWORD PTR _BufferDescription$6[ebp+4], eax
  00148	89 45 a8	 mov	 DWORD PTR _BufferDescription$6[ebp+8], eax
  0014b	89 45 ac	 mov	 DWORD PTR _BufferDescription$6[ebp+12], eax
  0014e	89 45 b0	 mov	 DWORD PTR _BufferDescription$6[ebp+16], eax
  00151	89 45 b4	 mov	 DWORD PTR _BufferDescription$6[ebp+20], eax
  00154	89 45 b8	 mov	 DWORD PTR _BufferDescription$6[ebp+24], eax
  00157	89 45 bc	 mov	 DWORD PTR _BufferDescription$6[ebp+28], eax
  0015a	89 45 c0	 mov	 DWORD PTR _BufferDescription$6[ebp+32], eax

; 253  :             BufferDescription.dwSize = sizeof(BufferDescription);

  0015d	c7 45 a0 24 00
	00 00		 mov	 DWORD PTR _BufferDescription$6[ebp], 36 ; 00000024H

; 254  :             BufferDescription.dwFlags = 0;

  00164	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _BufferDescription$6[ebp+4], 0

; 255  :             BufferDescription.dwBufferBytes = BufferSize;

  0016b	8b 4d 10	 mov	 ecx, DWORD PTR _BufferSize$[ebp]
  0016e	89 4d a8	 mov	 DWORD PTR _BufferDescription$6[ebp+8], ecx

; 256  :             BufferDescription.lpwfxFormat = &WaveFormat;

  00171	8d 55 e8	 lea	 edx, DWORD PTR _WaveFormat$8[ebp]
  00174	89 55 b0	 mov	 DWORD PTR _BufferDescription$6[ebp+16], edx

; 257  :             HRESULT Error = DirectSound->CreateSoundBuffer(&BufferDescription, &GlobalSecondaryBuffer, 0);

  00177	6a 00		 push	 0
  00179	68 00 00 00 00	 push	 OFFSET ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  0017e	8d 45 a0	 lea	 eax, DWORD PTR _BufferDescription$6[ebp]
  00181	50		 push	 eax
  00182	8b 4d 9c	 mov	 ecx, DWORD PTR _DirectSound$5[ebp]
  00185	8b 11		 mov	 edx, DWORD PTR [ecx]
  00187	8b 45 9c	 mov	 eax, DWORD PTR _DirectSound$5[ebp]
  0018a	50		 push	 eax
  0018b	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0018e	ff d1		 call	 ecx
  00190	89 45 88	 mov	 DWORD PTR _Error$1[ebp], eax

; 258  : 
; 259  :             if(SUCCEEDED(Error)) {

  00193	83 7d 88 00	 cmp	 DWORD PTR _Error$1[ebp], 0
  00197	7c 0b		 jl	 SHORT $LN1@Win32InitD

; 260  :                 OutputDebugStringA("Secondary buffer created successfuly\n");

  00199	68 00 00 00 00	 push	 OFFSET $SG87742
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
$LN1@Win32InitD:

; 261  :             }
; 262  :         }
; 263  :         else {
; 264  :             // TODO Diagnositc
; 265  :         }
; 266  :     }
; 267  : }

  001a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a7	33 cd		 xor	 ecx, ebp
  001a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ae	8b e5		 mov	 esp, ebp
  001b0	5d		 pop	 ebp
  001b1	c3		 ret	 0
?Win32InitDSound@@YAXPAUHWND__@@HH@Z ENDP		; Win32InitDSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_XInputLibrary$ = -4					; size = 4
?Wind32LoadXInput@@YAXXZ PROC				; Wind32LoadXInput

; 182  : Wind32LoadXInput(void) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 183  :     // TODO Test on windows 8
; 184  :     HMODULE XInputLibrary = LoadLibraryA("xinput1_4.dll");

  00004	68 00 00 00 00	 push	 OFFSET $SG87698
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0000f	89 45 fc	 mov	 DWORD PTR _XInputLibrary$[ebp], eax

; 185  :     if(!XInputLibrary)

  00012	83 7d fc 00	 cmp	 DWORD PTR _XInputLibrary$[ebp], 0
  00016	75 0e		 jne	 SHORT $LN2@Wind32Load

; 186  :     {
; 187  :         // TODO(casey): Diagnostic
; 188  :         XInputLibrary = LoadLibraryA("xinput9_1_0.dll");

  00018	68 00 00 00 00	 push	 OFFSET $SG87700
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  00023	89 45 fc	 mov	 DWORD PTR _XInputLibrary$[ebp], eax
$LN2@Wind32Load:

; 189  :     }
; 190  :     if(!XInputLibrary) {

  00026	83 7d fc 00	 cmp	 DWORD PTR _XInputLibrary$[ebp], 0
  0002a	75 0e		 jne	 SHORT $LN3@Wind32Load

; 191  :         // TODO Diagnostic
; 192  :         XInputLibrary = LoadLibraryA("xinput1_3.dll");

  0002c	68 00 00 00 00	 push	 OFFSET $SG87702
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  00037	89 45 fc	 mov	 DWORD PTR _XInputLibrary$[ebp], eax
$LN3@Wind32Load:

; 193  :     }
; 194  :     if(XInputLibrary) {

  0003a	83 7d fc 00	 cmp	 DWORD PTR _XInputLibrary$[ebp], 0
  0003e	74 4e		 je	 SHORT $LN1@Wind32Load

; 195  :         XInputGetState = (x_input_get_state *)GetProcAddress(XInputLibrary, "XInputGetState" );

  00040	68 00 00 00 00	 push	 OFFSET $SG87705
  00045	8b 45 fc	 mov	 eax, DWORD PTR _XInputLibrary$[ebp]
  00048	50		 push	 eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0004f	a3 00 00 00 00	 mov	 DWORD PTR ?XInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, eax

; 196  :         if(!XInputGetState) {XInputGetState = XInputGetStateStub;}

  00054	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?XInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, 0
  0005b	75 0a		 jne	 SHORT $LN6@Wind32Load
  0005d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?XInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA, OFFSET ?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ; XInputGetStateStub
$LN6@Wind32Load:

; 197  :         XInputSetState = (x_input_set_state *)GetProcAddress(XInputLibrary, "XInputSetState" );

  00067	68 00 00 00 00	 push	 OFFSET $SG87707
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _XInputLibrary$[ebp]
  0006f	51		 push	 ecx
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00076	a3 00 00 00 00	 mov	 DWORD PTR ?XInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, eax

; 198  :         if(!XInputSetState) {XInputSetState = XInputSetStateStub;}

  0007b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?XInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, 0
  00082	75 0a		 jne	 SHORT $LN1@Wind32Load
  00084	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?XInputSetState_@@3P6GKKPAU_XINPUT_VIBRATION@@@ZA, OFFSET ?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ; XInputSetStateStub
$LN1@Wind32Load:

; 199  : 
; 200  :         // TODO Diagnostic
; 201  :     }
; 202  :     else {
; 203  :         // TODO Diagnostic
; 204  :     }
; 205  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?Wind32LoadXInput@@YAXXZ ENDP				; Wind32LoadXInput
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
;	COMDAT ?SafeTruncateUInt64@@YAI_K@Z
_TEXT	SEGMENT
_Result$ = -4						; size = 4
_Value$ = 8						; size = 8
?SafeTruncateUInt64@@YAI_K@Z PROC			; SafeTruncateUInt64, COMDAT

; 89   : SafeTruncateUInt64(uint64 Value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 90   :     Assert(Value <= 0xFFFFFFFF);

  00004	83 7d 0c 00	 cmp	 DWORD PTR _Value$[ebp+4], 0
  00008	77 06		 ja	 SHORT $LN4@SafeTrunca
  0000a	83 7d 08 ff	 cmp	 DWORD PTR _Value$[ebp], -1
  0000e	76 0a		 jbe	 SHORT $LN2@SafeTrunca
$LN4@SafeTrunca:
  00010	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ds:0, 0
$LN2@SafeTrunca:

; 91   :     uint32 Result = (uint32)Value;

  0001a	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  0001d	89 45 fc	 mov	 DWORD PTR _Result$[ebp], eax

; 92   :     return(Result);

  00020	8b 45 fc	 mov	 eax, DWORD PTR _Result$[ebp]

; 93   : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?SafeTruncateUInt64@@YAI_K@Z ENDP			; SafeTruncateUInt64
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_dwUserIndex$ = 8					; size = 4
_pVibration$ = 12					; size = 4
?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z PROC	; XInputSetStateStub

; 77   : X_INPUT_SET_STATE(XInputSetStateStub) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   :     return(ERROR_DEVICE_NOT_CONNECTED);

  00003	b8 8f 04 00 00	 mov	 eax, 1167		; 0000048fH

; 79   : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?XInputSetStateStub@@YGKKPAU_XINPUT_VIBRATION@@@Z ENDP	; XInputSetStateStub
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_dwUserIndex$ = 8					; size = 4
_pState$ = 12						; size = 4
?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z PROC	; XInputGetStateStub

; 68   : X_INPUT_GET_STATE(XInputGetStateStub) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :     return(ERROR_DEVICE_NOT_CONNECTED);

  00003	b8 8f 04 00 00	 mov	 eax, 1167		; 0000048fH

; 70   : }

  00008	5d		 pop	 ebp
  00009	c2 08 00	 ret	 8
?XInputGetStateStub@@YGKKPAU_XINPUT_STATE@@@Z ENDP	; XInputGetStateStub
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_MCPF$1 = -1136						; size = 8
_FPS$2 = -1128						; size = 8
_MSPerFrame$3 = -1120					; size = 8
_Left$4 = -1112						; size = 4
_Up$5 = -1108						; size = 4
_Down$6 = -1104						; size = 4
tv684 = -1100						; size = 8
tv682 = -1092						; size = 8
_Right$7 = -1084					; size = 4
_TotalSize$8 = -1080					; size = 8
_PerfCountFrequencyResult$ = -1072			; size = 8
_WindowClass$ = -1064					; size = 40
_CyclesElapsed$9 = -1024				; size = 8
_Dimension$10 = -1016					; size = 8
_BaseAddress$11 = -1008					; size = 4
$T12 = -1004						; size = 8
_Temp$13 = -996						; size = 4
_WriteCursor$14 = -992					; size = 4
_DeviceContext$15 = -988				; size = 4
_Buffer$16 = -984					; size = 16
_LastCounter$17 = -968					; size = 8
_GameMemory$18 = -960					; size = 40
_EndCounter$19 = -920					; size = 8
_SoundBuffer$20 = -912					; size = 12
_CounterElapsed$21 = -900				; size = 8
_Samples$22 = -892					; size = 4
_KeyboardController$23 = -888				; size = 4
_MaxControllerCount$24 = -884				; size = 4
_PerfCountFrequency$ = -880				; size = 8
_LastCycleCount$25 = -872				; size = 8
_SoundIsValid$26 = -864					; size = 4
_EndCycleCount$27 = -860				; size = 8
_PlayCursor$28 = -852					; size = 4
_OldInput$29 = -848					; size = 4
_Window$30 = -844					; size = 4
_Y$31 = -840						; size = 4
_X$32 = -836						; size = 4
_TargetCursor$33 = -832					; size = 4
_NewInput$34 = -828					; size = 4
_ByteToLock$35 = -824					; size = 4
_ControllerIndex$36 = -820				; size = 4
_BytesToWrite$37 = -816					; size = 4
_OldController$38 = -812				; size = 4
_NewController$39 = -808				; size = 4
_Pad$40 = -804						; size = 4
_SoundOutput$41 = -800					; size = 24
_ZeroController$42 = -776				; size = 84
_ControllerState$43 = -692				; size = 16
_Input$44 = -676					; size = 672
__$ArrayPad$ = -4					; size = 4
_Instance$ = 8						; size = 4
_PrevInstance$ = 12					; size = 4
_CmdLine$ = 16						; size = 4
_ShowCode$ = 20						; size = 4
_WinMain@16 PROC

; 542  : ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 04 00
	00		 sub	 esp, 1136		; 00000470H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi

; 543  :     LARGE_INTEGER PerfCountFrequencyResult;
; 544  :     QueryPerformanceFrequency(&PerfCountFrequencyResult);

  00015	8d 85 d0 fb ff
	ff		 lea	 eax, DWORD PTR _PerfCountFrequencyResult$[ebp]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4

; 545  :     int64 PerfCountFrequency = PerfCountFrequencyResult.QuadPart;

  00022	8b 8d d0 fb ff
	ff		 mov	 ecx, DWORD PTR _PerfCountFrequencyResult$[ebp]
  00028	89 8d 90 fc ff
	ff		 mov	 DWORD PTR _PerfCountFrequency$[ebp], ecx
  0002e	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _PerfCountFrequencyResult$[ebp+4]
  00034	89 95 94 fc ff
	ff		 mov	 DWORD PTR _PerfCountFrequency$[ebp+4], edx

; 546  : 
; 547  :     Wind32LoadXInput();

  0003a	e8 00 00 00 00	 call	 ?Wind32LoadXInput@@YAXXZ ; Wind32LoadXInput

; 548  : 
; 549  :     WNDCLASSA WindowClass = {};

  0003f	33 c0		 xor	 eax, eax
  00041	89 85 d8 fb ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp], eax
  00047	89 85 dc fb ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+4], eax
  0004d	89 85 e0 fb ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+8], eax
  00053	89 85 e4 fb ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+12], eax
  00059	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+16], eax
  0005f	89 85 ec fb ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+20], eax
  00065	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+24], eax
  0006b	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+28], eax
  00071	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+32], eax
  00077	89 85 fc fb ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+36], eax

; 550  : 
; 551  :     Win32ResizeDIBSection(&GlobalBackbuffer, 1280, 720);

  0007d	68 d0 02 00 00	 push	 720			; 000002d0H
  00082	68 00 05 00 00	 push	 1280			; 00000500H
  00087	68 00 00 00 00	 push	 OFFSET ?GlobalBackbuffer@@3Uwin32_offscreen_buffer@@A
  0008c	e8 00 00 00 00	 call	 ?Win32ResizeDIBSection@@YAXPAUwin32_offscreen_buffer@@HH@Z ; Win32ResizeDIBSection
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 552  :     
; 553  :     WindowClass.style = CS_HREDRAW|CS_VREDRAW;

  00094	c7 85 d8 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp], 3

; 554  :     WindowClass.lpfnWndProc = Win32MainWindowCallback;

  0009e	c7 85 dc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp+4], OFFSET ?Win32MainWindowCallback@@YGJPAUHWND__@@IIJ@Z ; Win32MainWindowCallback

; 555  :     WindowClass.hInstance = Instance;

  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _Instance$[ebp]
  000ab	89 8d e8 fb ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+16], ecx

; 556  : //    WindowClass.hIcon;
; 557  :     WindowClass.lpszClassName = "HandmadeHeroWindowClass";

  000b1	c7 85 fc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp+36], OFFSET $SG87959

; 558  : 
; 559  : 
; 560  :     if (RegisterClass(&WindowClass)) {

  000bb	8d 95 d8 fb ff
	ff		 lea	 edx, DWORD PTR _WindowClass$[ebp]
  000c1	52		 push	 edx
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassA@4
  000c8	0f b7 c0	 movzx	 eax, ax
  000cb	85 c0		 test	 eax, eax
  000cd	0f 84 87 09 00
	00		 je	 $LN7@WinMain

; 561  :         HWND Window = CreateWindowExA(

  000d3	6a 00		 push	 0
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _Instance$[ebp]
  000d8	51		 push	 ecx
  000d9	6a 00		 push	 0
  000db	6a 00		 push	 0
  000dd	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000e2	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000e7	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000ec	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000f1	68 00 00 cf 10	 push	 282001408		; 10cf0000H
  000f6	68 00 00 00 00	 push	 OFFSET $SG87962
  000fb	8b 95 fc fb ff
	ff		 mov	 edx, DWORD PTR _WindowClass$[ebp+36]
  00101	52		 push	 edx
  00102	6a 00		 push	 0
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  0010a	89 85 b4 fc ff
	ff		 mov	 DWORD PTR _Window$30[ebp], eax

; 562  :             0,
; 563  :             WindowClass.lpszClassName,
; 564  :             "Handmade Hero",
; 565  :             WS_OVERLAPPEDWINDOW|WS_VISIBLE,
; 566  :             CW_USEDEFAULT,
; 567  :             CW_USEDEFAULT,
; 568  :             CW_USEDEFAULT,
; 569  :             CW_USEDEFAULT,
; 570  :             0,
; 571  :             0,
; 572  :             Instance,
; 573  :             0
; 574  :         );
; 575  :         if(Window){

  00110	83 bd b4 fc ff
	ff 00		 cmp	 DWORD PTR _Window$30[ebp], 0
  00117	0f 84 3d 09 00
	00		 je	 $LN9@WinMain

; 576  :             HDC DeviceContext = GetDC(Window);

  0011d	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _Window$30[ebp]
  00123	50		 push	 eax
  00124	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  0012a	89 85 24 fc ff
	ff		 mov	 DWORD PTR _DeviceContext$15[ebp], eax

; 577  : 
; 578  :             // Sound Test
; 579  :             win32_sound_output SoundOutput = {};

  00130	33 c9		 xor	 ecx, ecx
  00132	89 8d e0 fc ff
	ff		 mov	 DWORD PTR _SoundOutput$41[ebp], ecx
  00138	89 8d e4 fc ff
	ff		 mov	 DWORD PTR _SoundOutput$41[ebp+4], ecx
  0013e	89 8d e8 fc ff
	ff		 mov	 DWORD PTR _SoundOutput$41[ebp+8], ecx
  00144	89 8d ec fc ff
	ff		 mov	 DWORD PTR _SoundOutput$41[ebp+12], ecx
  0014a	89 8d f0 fc ff
	ff		 mov	 DWORD PTR _SoundOutput$41[ebp+16], ecx
  00150	89 8d f4 fc ff
	ff		 mov	 DWORD PTR _SoundOutput$41[ebp+20], ecx

; 580  :             SoundOutput.SamplesPerSecond = 48000;

  00156	c7 85 e0 fc ff
	ff 80 bb 00 00	 mov	 DWORD PTR _SoundOutput$41[ebp], 48000 ; 0000bb80H

; 581  :             // SoundOutput.ToneHz = 256;
; 582  :             // SoundOutput.ToneVolume = 3000;
; 583  :             SoundOutput.RunningSampleIndex = 0;

  00160	c7 85 e4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _SoundOutput$41[ebp+4], 0

; 584  :             // SoundOutput.WavePeriod = SoundOutput.SamplesPerSecond/SoundOutput.ToneHz;
; 585  :             SoundOutput.BytesPerSample = sizeof(int16)*2;

  0016a	c7 85 e8 fc ff
	ff 04 00 00 00	 mov	 DWORD PTR _SoundOutput$41[ebp+8], 4

; 586  :             SoundOutput.LatencySampleCount = SoundOutput.SamplesPerSecond / 15;

  00174	8b 85 e0 fc ff
	ff		 mov	 eax, DWORD PTR _SoundOutput$41[ebp]
  0017a	99		 cdq
  0017b	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00180	f7 f9		 idiv	 ecx
  00182	89 85 f4 fc ff
	ff		 mov	 DWORD PTR _SoundOutput$41[ebp+20], eax

; 587  :             SoundOutput.SecondaryBufferSize = SoundOutput.SamplesPerSecond*SoundOutput.BytesPerSample;

  00188	8b 95 e0 fc ff
	ff		 mov	 edx, DWORD PTR _SoundOutput$41[ebp]
  0018e	0f af 95 e8 fc
	ff ff		 imul	 edx, DWORD PTR _SoundOutput$41[ebp+8]
  00195	89 95 ec fc ff
	ff		 mov	 DWORD PTR _SoundOutput$41[ebp+12], edx

; 588  :             Win32InitDSound(Window, SoundOutput.SamplesPerSecond, SoundOutput.SecondaryBufferSize);

  0019b	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR _SoundOutput$41[ebp+12]
  001a1	50		 push	 eax
  001a2	8b 8d e0 fc ff
	ff		 mov	 ecx, DWORD PTR _SoundOutput$41[ebp]
  001a8	51		 push	 ecx
  001a9	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _Window$30[ebp]
  001af	52		 push	 edx
  001b0	e8 00 00 00 00	 call	 ?Win32InitDSound@@YAXPAUHWND__@@HH@Z ; Win32InitDSound
  001b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 589  :             win32ClearBuffer(&SoundOutput);

  001b8	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _SoundOutput$41[ebp]
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 ?win32ClearBuffer@@YAXPAUwin32_sound_output@@@Z ; win32ClearBuffer
  001c4	83 c4 04	 add	 esp, 4

; 590  :             GlobalSecondaryBuffer->Play(0, 0, DSBPLAY_LOOPING);

  001c7	6a 01		 push	 1
  001c9	6a 00		 push	 0
  001cb	6a 00		 push	 0
  001cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  001d3	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  001da	50		 push	 eax
  001db	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  001de	ff d1		 call	 ecx

; 591  :             // bool32 SoundIsPlaying = true;
; 592  : 
; 593  :             GlobalRunning = true;

  001e0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?GlobalRunning@@3HA, 1

; 594  : 
; 595  :             // TODO Pool with bitmap VirtualAlloc
; 596  :             int16 *Samples = (int16 *)VirtualAlloc(0, SoundOutput.SecondaryBufferSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  001ea	6a 04		 push	 4
  001ec	68 00 30 00 00	 push	 12288			; 00003000H
  001f1	8b 95 ec fc ff
	ff		 mov	 edx, DWORD PTR _SoundOutput$41[ebp+12]
  001f7	52		 push	 edx
  001f8	6a 00		 push	 0
  001fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
  00200	89 85 84 fc ff
	ff		 mov	 DWORD PTR _Samples$22[ebp], eax

; 597  : 
; 598  : #if HANDMADE_INTERNAL
; 599  :             LPVOID BaseAddress = 0;

  00206	c7 85 10 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _BaseAddress$11[ebp], 0

; 600  : #else
; 601  :             LPVOID BaseAddress = Terabytes(2);
; 602  : #endif
; 603  : 
; 604  :             game_memory GameMemory = {};

  00210	33 c0		 xor	 eax, eax
  00212	89 85 40 fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp], eax
  00218	89 85 44 fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp+4], eax
  0021e	89 85 48 fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp+8], eax
  00224	89 85 4c fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp+12], eax
  0022a	89 85 50 fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp+16], eax
  00230	89 85 54 fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp+20], eax
  00236	89 85 58 fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp+24], eax
  0023c	89 85 5c fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp+28], eax
  00242	89 85 60 fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp+32], eax
  00248	89 85 64 fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp+36], eax

; 605  :             GameMemory.PermanentStorageSize = Megabytes(64);

  0024e	c7 85 48 fc ff
	ff 00 00 00 04	 mov	 DWORD PTR _GameMemory$18[ebp+8], 67108864 ; 04000000H
  00258	c7 85 4c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _GameMemory$18[ebp+12], 0

; 606  :             GameMemory.TransientStorageSize = Gigabytes(1);

  00262	c7 85 58 fc ff
	ff 00 00 00 40	 mov	 DWORD PTR _GameMemory$18[ebp+24], 1073741824 ; 40000000H
  0026c	c7 85 5c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _GameMemory$18[ebp+28], 0

; 607  :             uint64 TotalSize = GameMemory.PermanentStorageSize + GameMemory.TransientStorageSize;

  00276	8b 8d 48 fc ff
	ff		 mov	 ecx, DWORD PTR _GameMemory$18[ebp+8]
  0027c	03 8d 58 fc ff
	ff		 add	 ecx, DWORD PTR _GameMemory$18[ebp+24]
  00282	8b 95 4c fc ff
	ff		 mov	 edx, DWORD PTR _GameMemory$18[ebp+12]
  00288	13 95 5c fc ff
	ff		 adc	 edx, DWORD PTR _GameMemory$18[ebp+28]
  0028e	89 8d c8 fb ff
	ff		 mov	 DWORD PTR _TotalSize$8[ebp], ecx
  00294	89 95 cc fb ff
	ff		 mov	 DWORD PTR _TotalSize$8[ebp+4], edx

; 608  :             GameMemory.PermanentStorage = VirtualAlloc(BaseAddress, (size_t)TotalSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  0029a	6a 04		 push	 4
  0029c	68 00 30 00 00	 push	 12288			; 00003000H
  002a1	8b 85 c8 fb ff
	ff		 mov	 eax, DWORD PTR _TotalSize$8[ebp]
  002a7	50		 push	 eax
  002a8	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _BaseAddress$11[ebp]
  002ae	51		 push	 ecx
  002af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
  002b5	89 85 50 fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp+16], eax

; 609  :             GameMemory.TransientStorage = ((uint8 *)GameMemory.PermanentStorage + GameMemory.PermanentStorageSize);

  002bb	8b 95 48 fc ff
	ff		 mov	 edx, DWORD PTR _GameMemory$18[ebp+8]
  002c1	03 95 50 fc ff
	ff		 add	 edx, DWORD PTR _GameMemory$18[ebp+16]
  002c7	89 95 60 fc ff
	ff		 mov	 DWORD PTR _GameMemory$18[ebp+32], edx

; 610  :             
; 611  : 
; 612  : 
; 613  :             if(Samples && GameMemory.PermanentStorage && GameMemory.TransientStorage) {

  002cd	83 bd 84 fc ff
	ff 00		 cmp	 DWORD PTR _Samples$22[ebp], 0
  002d4	0f 84 80 07 00
	00		 je	 $LN11@WinMain
  002da	83 bd 50 fc ff
	ff 00		 cmp	 DWORD PTR _GameMemory$18[ebp+16], 0
  002e1	0f 84 73 07 00
	00		 je	 $LN11@WinMain
  002e7	83 bd 60 fc ff
	ff 00		 cmp	 DWORD PTR _GameMemory$18[ebp+32], 0
  002ee	0f 84 66 07 00
	00		 je	 $LN11@WinMain

; 614  : 
; 615  : 
; 616  :                 game_input Input[2] = {};

  002f4	68 a0 02 00 00	 push	 672			; 000002a0H
  002f9	6a 00		 push	 0
  002fb	8d 85 5c fd ff
	ff		 lea	 eax, DWORD PTR _Input$44[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 _memset
  00307	83 c4 0c	 add	 esp, 12			; 0000000cH

; 617  :                 game_input *NewInput = &Input[0];

  0030a	b9 50 01 00 00	 mov	 ecx, 336		; 00000150H
  0030f	6b d1 00	 imul	 edx, ecx, 0
  00312	8d 84 15 5c fd
	ff ff		 lea	 eax, DWORD PTR _Input$44[ebp+edx]
  00319	89 85 c4 fc ff
	ff		 mov	 DWORD PTR _NewInput$34[ebp], eax

; 618  :                 game_input *OldInput = &Input[1];

  0031f	b9 50 01 00 00	 mov	 ecx, 336		; 00000150H
  00324	c1 e1 00	 shl	 ecx, 0
  00327	8d 94 0d 5c fd
	ff ff		 lea	 edx, DWORD PTR _Input$44[ebp+ecx]
  0032e	89 95 b0 fc ff
	ff		 mov	 DWORD PTR _OldInput$29[ebp], edx

; 619  : 
; 620  :                 LARGE_INTEGER LastCounter;
; 621  :                 QueryPerformanceCounter(&LastCounter);

  00334	8d 85 38 fc ff
	ff		 lea	 eax, DWORD PTR _LastCounter$17[ebp]
  0033a	50		 push	 eax
  0033b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4

; 622  :                 int64 LastCycleCount = __rdtsc();

  00341	0f 31		 rdtsc
  00343	89 85 98 fc ff
	ff		 mov	 DWORD PTR _LastCycleCount$25[ebp], eax
  00349	89 95 9c fc ff
	ff		 mov	 DWORD PTR _LastCycleCount$25[ebp+4], edx
$LN2@WinMain:

; 623  : 
; 624  :                 // game loop begin
; 625  :                 while (GlobalRunning) {

  0034f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GlobalRunning@@3HA, 0
  00356	0f 84 fe 06 00
	00		 je	 $LN3@WinMain

; 626  : 
; 627  :                     game_controller_input *KeyboardController = &NewInput->Controllers[0];

  0035c	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00361	6b d1 00	 imul	 edx, ecx, 0
  00364	03 95 c4 fc ff
	ff		 add	 edx, DWORD PTR _NewInput$34[ebp]
  0036a	89 95 88 fc ff
	ff		 mov	 DWORD PTR _KeyboardController$23[ebp], edx

; 628  :                     // TODO Zeroing macro
; 629  :                     // TODO We can't zero everything because the up/down state will be wrong
; 630  :                     game_controller_input ZeroController = {};

  00370	6a 54		 push	 84			; 00000054H
  00372	6a 00		 push	 0
  00374	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _ZeroController$42[ebp]
  0037a	50		 push	 eax
  0037b	e8 00 00 00 00	 call	 _memset
  00380	83 c4 0c	 add	 esp, 12			; 0000000cH

; 631  :                     *KeyboardController = ZeroController;

  00383	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  00388	8d b5 f8 fc ff
	ff		 lea	 esi, DWORD PTR _ZeroController$42[ebp]
  0038e	8b bd 88 fc ff
	ff		 mov	 edi, DWORD PTR _KeyboardController$23[ebp]
  00394	f3 a5		 rep movsd

; 632  :                     
; 633  :                     Win32ProcessPendingMessage(KeyboardController);

  00396	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _KeyboardController$23[ebp]
  0039c	51		 push	 ecx
  0039d	e8 00 00 00 00	 call	 ?Win32ProcessPendingMessage@@YAXPAUgame_controller_input@@@Z ; Win32ProcessPendingMessage
  003a2	83 c4 04	 add	 esp, 4

; 634  : 
; 635  :                     
; 636  : 
; 637  :                     DWORD MaxControllerCount = XUSER_MAX_COUNT;

  003a5	c7 85 8c fc ff
	ff 04 00 00 00	 mov	 DWORD PTR _MaxControllerCount$24[ebp], 4

; 638  :                     if(MaxControllerCount > ArrayCount(NewInput->Controllers)) {

  003af	83 bd 8c fc ff
	ff 04		 cmp	 DWORD PTR _MaxControllerCount$24[ebp], 4
  003b6	76 0a		 jbe	 SHORT $LN13@WinMain

; 639  :                         MaxControllerCount = ArrayCount(NewInput->Controllers);

  003b8	c7 85 8c fc ff
	ff 04 00 00 00	 mov	 DWORD PTR _MaxControllerCount$24[ebp], 4
$LN13@WinMain:

; 640  :                     }
; 641  :                     for(
; 642  :                         DWORD ControllerIndex = 0;

  003c2	c7 85 cc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _ControllerIndex$36[ebp], 0
  003cc	eb 0f		 jmp	 SHORT $LN6@WinMain
$LN4@WinMain:

; 644  :                         ++ControllerIndex

  003ce	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR _ControllerIndex$36[ebp]
  003d4	83 c2 01	 add	 edx, 1
  003d7	89 95 cc fc ff
	ff		 mov	 DWORD PTR _ControllerIndex$36[ebp], edx
$LN6@WinMain:

; 643  :                         ControllerIndex < XUSER_MAX_COUNT;

  003dd	83 bd cc fc ff
	ff 04		 cmp	 DWORD PTR _ControllerIndex$36[ebp], 4
  003e4	0f 83 d7 02 00
	00		 jae	 $LN5@WinMain

; 645  :                     ) {
; 646  :                         game_controller_input *OldController = &OldInput->Controllers[ControllerIndex];

  003ea	6b 85 cc fc ff
	ff 54		 imul	 eax, DWORD PTR _ControllerIndex$36[ebp], 84
  003f1	03 85 b0 fc ff
	ff		 add	 eax, DWORD PTR _OldInput$29[ebp]
  003f7	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _OldController$38[ebp], eax

; 647  :                         game_controller_input *NewController = &NewInput->Controllers[ControllerIndex];

  003fd	6b 8d cc fc ff
	ff 54		 imul	 ecx, DWORD PTR _ControllerIndex$36[ebp], 84
  00404	03 8d c4 fc ff
	ff		 add	 ecx, DWORD PTR _NewInput$34[ebp]
  0040a	89 8d d8 fc ff
	ff		 mov	 DWORD PTR _NewController$39[ebp], ecx

; 648  : 
; 649  : 
; 650  :                         XINPUT_STATE ControllerState;
; 651  :                         if(XInputGetState(ControllerIndex, &ControllerState) == ERROR_SUCCESS) {

  00410	8d 95 4c fd ff
	ff		 lea	 edx, DWORD PTR _ControllerState$43[ebp]
  00416	52		 push	 edx
  00417	8b 85 cc fc ff
	ff		 mov	 eax, DWORD PTR _ControllerIndex$36[ebp]
  0041d	50		 push	 eax
  0041e	ff 15 00 00 00
	00		 call	 DWORD PTR ?XInputGetState_@@3P6GKKPAU_XINPUT_STATE@@@ZA
  00424	85 c0		 test	 eax, eax
  00426	0f 85 90 02 00
	00		 jne	 $LN14@WinMain

; 652  :                             // NOTE Controller is plugged in
; 653  :                             // TODO See if ControllerState.dwPacketNumber increments
; 654  :                             XINPUT_GAMEPAD *Pad = &ControllerState.Gamepad;

  0042c	8d 8d 50 fd ff
	ff		 lea	 ecx, DWORD PTR _ControllerState$43[ebp+4]
  00432	89 8d dc fc ff
	ff		 mov	 DWORD PTR _Pad$40[ebp], ecx

; 655  : 
; 656  :                             // TODO DPad
; 657  :                             bool32 Up = (Pad->wButtons & XINPUT_GAMEPAD_DPAD_UP);

  00438	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _Pad$40[ebp]
  0043e	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00441	83 e0 01	 and	 eax, 1
  00444	89 85 ac fb ff
	ff		 mov	 DWORD PTR _Up$5[ebp], eax

; 658  :                             bool32 Down = (Pad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN);

  0044a	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR _Pad$40[ebp]
  00450	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00453	83 e2 02	 and	 edx, 2
  00456	89 95 b0 fb ff
	ff		 mov	 DWORD PTR _Down$6[ebp], edx

; 659  :                             bool32 Left = (Pad->wButtons & XINPUT_GAMEPAD_DPAD_LEFT);

  0045c	8b 85 dc fc ff
	ff		 mov	 eax, DWORD PTR _Pad$40[ebp]
  00462	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00465	83 e1 04	 and	 ecx, 4
  00468	89 8d a8 fb ff
	ff		 mov	 DWORD PTR _Left$4[ebp], ecx

; 660  :                             bool32 Right = (Pad->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT);

  0046e	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _Pad$40[ebp]
  00474	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00477	83 e0 08	 and	 eax, 8
  0047a	89 85 c4 fb ff
	ff		 mov	 DWORD PTR _Right$7[ebp], eax

; 661  : 
; 662  :                             NewController->IsAnalogue = true;

  00480	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _NewController$39[ebp]
  00486	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 663  :                             real32 X;
; 664  :                             if(Pad->sThumbLX < 0) {

  0048c	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _Pad$40[ebp]
  00492	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  00496	85 c0		 test	 eax, eax
  00498	7d 20		 jge	 SHORT $LN16@WinMain

; 665  :                                 X = (real32)Pad->sThumbLX / 32768.0f; 

  0049a	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR _Pad$40[ebp]
  004a0	0f bf 51 04	 movsx	 edx, WORD PTR [ecx+4]
  004a4	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  004a8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47000000
  004b0	f3 0f 11 85 bc
	fc ff ff	 movss	 DWORD PTR _X$32[ebp], xmm0

; 666  :                             }
; 667  :                             else {

  004b8	eb 1e		 jmp	 SHORT $LN17@WinMain
$LN16@WinMain:

; 668  :                                 X = (real32)Pad->sThumbLX / 32767.0f;

  004ba	8b 85 dc fc ff
	ff		 mov	 eax, DWORD PTR _Pad$40[ebp]
  004c0	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  004c4	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  004c8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46fffe00
  004d0	f3 0f 11 85 bc
	fc ff ff	 movss	 DWORD PTR _X$32[ebp], xmm0
$LN17@WinMain:

; 669  :                             }
; 670  : 
; 671  :                             real32 Y;
; 672  :                             if(Pad->sThumbLX < 0) {

  004d8	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _Pad$40[ebp]
  004de	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  004e2	85 c0		 test	 eax, eax
  004e4	7d 20		 jge	 SHORT $LN18@WinMain

; 673  :                                 Y = (real32)Pad->sThumbLY / 32768.0f; 

  004e6	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR _Pad$40[ebp]
  004ec	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  004f0	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  004f4	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47000000
  004fc	f3 0f 11 85 b8
	fc ff ff	 movss	 DWORD PTR _Y$31[ebp], xmm0

; 674  :                             }
; 675  :                             else {

  00504	eb 1e		 jmp	 SHORT $LN19@WinMain
$LN18@WinMain:

; 676  :                                 Y = (real32)Pad->sThumbLY / 32767.0f;

  00506	8b 85 dc fc ff
	ff		 mov	 eax, DWORD PTR _Pad$40[ebp]
  0050c	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00510	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00514	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46fffe00
  0051c	f3 0f 11 85 b8
	fc ff ff	 movss	 DWORD PTR _Y$31[ebp], xmm0
$LN19@WinMain:

; 677  :                             }
; 678  : 
; 679  :                             NewController->StartX = OldController->EndX;

  00524	8b 95 d8 fc ff
	ff		 mov	 edx, DWORD PTR _NewController$39[ebp]
  0052a	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _OldController$38[ebp]
  00530	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00533	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 680  :                             NewController->StartY = OldController->EndY;

  00536	8b 95 d8 fc ff
	ff		 mov	 edx, DWORD PTR _NewController$39[ebp]
  0053c	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _OldController$38[ebp]
  00542	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00545	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 681  : 
; 682  :                             // TODO Deadzones XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE
; 683  :                             // TODO Min/max macros
; 684  :                             NewController->MinX = NewController->MaxX = NewController->EndX = X;

  00548	8b 95 d8 fc ff
	ff		 mov	 edx, DWORD PTR _NewController$39[ebp]
  0054e	f3 0f 10 85 bc
	fc ff ff	 movss	 xmm0, DWORD PTR _X$32[ebp]
  00556	f3 0f 11 42 1c	 movss	 DWORD PTR [edx+28], xmm0
  0055b	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _NewController$39[ebp]
  00561	f3 0f 10 85 bc
	fc ff ff	 movss	 xmm0, DWORD PTR _X$32[ebp]
  00569	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0
  0056e	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _NewController$39[ebp]
  00574	f3 0f 10 85 bc
	fc ff ff	 movss	 xmm0, DWORD PTR _X$32[ebp]
  0057c	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0

; 685  :                             NewController->MinY = NewController->MaxY = NewController->EndY = Y;

  00581	8b 95 d8 fc ff
	ff		 mov	 edx, DWORD PTR _NewController$39[ebp]
  00587	f3 0f 10 85 b8
	fc ff ff	 movss	 xmm0, DWORD PTR _Y$31[ebp]
  0058f	f3 0f 11 42 20	 movss	 DWORD PTR [edx+32], xmm0
  00594	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _NewController$39[ebp]
  0059a	f3 0f 10 85 b8
	fc ff ff	 movss	 xmm0, DWORD PTR _Y$31[ebp]
  005a2	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
  005a7	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _NewController$39[ebp]
  005ad	f3 0f 10 85 b8
	fc ff ff	 movss	 xmm0, DWORD PTR _Y$31[ebp]
  005b5	f3 0f 11 41 10	 movss	 DWORD PTR [ecx+16], xmm0

; 686  : 
; 687  : 
; 688  : 
; 689  :                             Win32ProcessXInputDigitalButton(Pad->wButtons, &OldController->Down, &NewController->Down, XINPUT_GAMEPAD_A);

  005ba	68 00 10 00 00	 push	 4096			; 00001000H
  005bf	8b 95 d8 fc ff
	ff		 mov	 edx, DWORD PTR _NewController$39[ebp]
  005c5	83 c2 2c	 add	 edx, 44			; 0000002cH
  005c8	52		 push	 edx
  005c9	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _OldController$38[ebp]
  005cf	83 c0 2c	 add	 eax, 44			; 0000002cH
  005d2	50		 push	 eax
  005d3	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR _Pad$40[ebp]
  005d9	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  005dc	52		 push	 edx
  005dd	e8 00 00 00 00	 call	 ?Win32ProcessXInputDigitalButton@@YAXKPAUgame_button_state@@0K@Z ; Win32ProcessXInputDigitalButton
  005e2	83 c4 10	 add	 esp, 16			; 00000010H

; 690  :                             Win32ProcessXInputDigitalButton(Pad->wButtons, &OldController->Right, &NewController->Right, XINPUT_GAMEPAD_B);

  005e5	68 00 20 00 00	 push	 8192			; 00002000H
  005ea	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _NewController$39[ebp]
  005f0	83 c0 3c	 add	 eax, 60			; 0000003cH
  005f3	50		 push	 eax
  005f4	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR _OldController$38[ebp]
  005fa	83 c1 3c	 add	 ecx, 60			; 0000003cH
  005fd	51		 push	 ecx
  005fe	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _Pad$40[ebp]
  00604	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00607	50		 push	 eax
  00608	e8 00 00 00 00	 call	 ?Win32ProcessXInputDigitalButton@@YAXKPAUgame_button_state@@0K@Z ; Win32ProcessXInputDigitalButton
  0060d	83 c4 10	 add	 esp, 16			; 00000010H

; 691  :                             Win32ProcessXInputDigitalButton(Pad->wButtons, &OldController->Left, &NewController->Left, XINPUT_GAMEPAD_X);

  00610	68 00 40 00 00	 push	 16384			; 00004000H
  00615	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _NewController$39[ebp]
  0061b	83 c1 34	 add	 ecx, 52			; 00000034H
  0061e	51		 push	 ecx
  0061f	8b 95 d4 fc ff
	ff		 mov	 edx, DWORD PTR _OldController$38[ebp]
  00625	83 c2 34	 add	 edx, 52			; 00000034H
  00628	52		 push	 edx
  00629	8b 85 dc fc ff
	ff		 mov	 eax, DWORD PTR _Pad$40[ebp]
  0062f	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00632	51		 push	 ecx
  00633	e8 00 00 00 00	 call	 ?Win32ProcessXInputDigitalButton@@YAXKPAUgame_button_state@@0K@Z ; Win32ProcessXInputDigitalButton
  00638	83 c4 10	 add	 esp, 16			; 00000010H

; 692  :                             Win32ProcessXInputDigitalButton(Pad->wButtons, &OldController->Up, &NewController->Up, XINPUT_GAMEPAD_Y);

  0063b	68 00 80 00 00	 push	 32768			; 00008000H
  00640	8b 95 d8 fc ff
	ff		 mov	 edx, DWORD PTR _NewController$39[ebp]
  00646	83 c2 24	 add	 edx, 36			; 00000024H
  00649	52		 push	 edx
  0064a	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _OldController$38[ebp]
  00650	83 c0 24	 add	 eax, 36			; 00000024H
  00653	50		 push	 eax
  00654	8b 8d dc fc ff
	ff		 mov	 ecx, DWORD PTR _Pad$40[ebp]
  0065a	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0065d	52		 push	 edx
  0065e	e8 00 00 00 00	 call	 ?Win32ProcessXInputDigitalButton@@YAXKPAUgame_button_state@@0K@Z ; Win32ProcessXInputDigitalButton
  00663	83 c4 10	 add	 esp, 16			; 00000010H

; 693  :                             Win32ProcessXInputDigitalButton(Pad->wButtons, &OldController->LeftShoulder, &NewController->LeftShoulder, XINPUT_GAMEPAD_LEFT_SHOULDER);

  00666	68 00 01 00 00	 push	 256			; 00000100H
  0066b	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _NewController$39[ebp]
  00671	83 c0 44	 add	 eax, 68			; 00000044H
  00674	50		 push	 eax
  00675	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR _OldController$38[ebp]
  0067b	83 c1 44	 add	 ecx, 68			; 00000044H
  0067e	51		 push	 ecx
  0067f	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR _Pad$40[ebp]
  00685	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00688	50		 push	 eax
  00689	e8 00 00 00 00	 call	 ?Win32ProcessXInputDigitalButton@@YAXKPAUgame_button_state@@0K@Z ; Win32ProcessXInputDigitalButton
  0068e	83 c4 10	 add	 esp, 16			; 00000010H

; 694  :                             Win32ProcessXInputDigitalButton(Pad->wButtons, &OldController->RightShoulder, &NewController->RightShoulder, XINPUT_GAMEPAD_RIGHT_SHOULDER);

  00691	68 00 02 00 00	 push	 512			; 00000200H
  00696	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _NewController$39[ebp]
  0069c	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0069f	51		 push	 ecx
  006a0	8b 95 d4 fc ff
	ff		 mov	 edx, DWORD PTR _OldController$38[ebp]
  006a6	83 c2 4c	 add	 edx, 76			; 0000004cH
  006a9	52		 push	 edx
  006aa	8b 85 dc fc ff
	ff		 mov	 eax, DWORD PTR _Pad$40[ebp]
  006b0	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  006b3	51		 push	 ecx
  006b4	e8 00 00 00 00	 call	 ?Win32ProcessXInputDigitalButton@@YAXKPAUgame_button_state@@0K@Z ; Win32ProcessXInputDigitalButton
  006b9	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@WinMain:

; 695  : 
; 696  :                             
; 697  : 
; 698  :                             // bool32 Start = (Pad->wButtons & XINPUT_GAMEPAD_START);
; 699  :                             // bool32 Back = (Pad->wButtons & XINPUT_GAMEPAD_BACK);
; 700  : 
; 701  :                             // if (AButton) {
; 702  :                             //     SoundOutput.ToneHz = 512 + (int32)256*(((real32)StickY / 30000.0f));
; 703  :                             //     SoundOutput.WavePeriod = SoundOutput.SamplesPerSecond/SoundOutput.ToneHz;
; 704  :                             // }
; 705  :                             // else {
; 706  :                             //     SoundOutput.ToneHz = 256;
; 707  :                             //     SoundOutput.WavePeriod = SoundOutput.SamplesPerSecond/SoundOutput.ToneHz;
; 708  :                             // }
; 709  :                         }
; 710  :                         else {
; 711  :                             // NOTE Controller is not available
; 712  :                         }
; 713  :                     }

  006bc	e9 0d fd ff ff	 jmp	 $LN4@WinMain
$LN5@WinMain:

; 714  : 
; 715  :                     DWORD ByteToLock = 0;

  006c1	c7 85 c8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _ByteToLock$35[ebp], 0

; 716  :                     DWORD TargetCursor = 0;

  006cb	c7 85 c0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _TargetCursor$33[ebp], 0

; 717  :                     DWORD BytesToWrite = 0;

  006d5	c7 85 d0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _BytesToWrite$37[ebp], 0

; 718  :                     DWORD PlayCursor = 0;

  006df	c7 85 ac fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _PlayCursor$28[ebp], 0

; 719  :                     DWORD WriteCursor = 0;

  006e9	c7 85 20 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _WriteCursor$14[ebp], 0

; 720  :                     bool32 SoundIsValid = false;

  006f3	c7 85 a0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _SoundIsValid$26[ebp], 0

; 721  :                     // TODO Tighten up sound logic so that we know where we should be 
; 722  :                     // writing to and can anticipate the time spent in the game update
; 723  :                     if(SUCCEEDED(GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor))) {

  006fd	8d 95 20 fc ff
	ff		 lea	 edx, DWORD PTR _WriteCursor$14[ebp]
  00703	52		 push	 edx
  00704	8d 85 ac fc ff
	ff		 lea	 eax, DWORD PTR _PlayCursor$28[ebp]
  0070a	50		 push	 eax
  0070b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  00711	8b 11		 mov	 edx, DWORD PTR [ecx]
  00713	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GlobalSecondaryBuffer@@3PAUIDirectSoundBuffer@@A
  00718	50		 push	 eax
  00719	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0071c	ff d1		 call	 ecx
  0071e	85 c0		 test	 eax, eax
  00720	0f 8c a4 00 00
	00		 jl	 $LN20@WinMain

; 724  :                         ByteToLock = (SoundOutput.RunningSampleIndex*SoundOutput.BytesPerSample) % SoundOutput.SecondaryBufferSize;

  00726	8b 85 e4 fc ff
	ff		 mov	 eax, DWORD PTR _SoundOutput$41[ebp+4]
  0072c	0f af 85 e8 fc
	ff ff		 imul	 eax, DWORD PTR _SoundOutput$41[ebp+8]
  00733	33 d2		 xor	 edx, edx
  00735	f7 b5 ec fc ff
	ff		 div	 DWORD PTR _SoundOutput$41[ebp+12]
  0073b	89 95 c8 fc ff
	ff		 mov	 DWORD PTR _ByteToLock$35[ebp], edx

; 725  :                         TargetCursor = (PlayCursor + (SoundOutput.LatencySampleCount*SoundOutput.BytesPerSample)) % SoundOutput.SecondaryBufferSize;

  00741	8b 85 f4 fc ff
	ff		 mov	 eax, DWORD PTR _SoundOutput$41[ebp+20]
  00747	0f af 85 e8 fc
	ff ff		 imul	 eax, DWORD PTR _SoundOutput$41[ebp+8]
  0074e	03 85 ac fc ff
	ff		 add	 eax, DWORD PTR _PlayCursor$28[ebp]
  00754	33 d2		 xor	 edx, edx
  00756	f7 b5 ec fc ff
	ff		 div	 DWORD PTR _SoundOutput$41[ebp+12]
  0075c	89 95 c0 fc ff
	ff		 mov	 DWORD PTR _TargetCursor$33[ebp], edx

; 726  :                         if(ByteToLock == TargetCursor) {

  00762	8b 95 c8 fc ff
	ff		 mov	 edx, DWORD PTR _ByteToLock$35[ebp]
  00768	3b 95 c0 fc ff
	ff		 cmp	 edx, DWORD PTR _TargetCursor$33[ebp]
  0076e	75 0a		 jne	 SHORT $LN21@WinMain

; 727  :                             BytesToWrite = 0;

  00770	c7 85 d0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _BytesToWrite$37[ebp], 0
$LN21@WinMain:

; 728  :                         }
; 729  :                         if(ByteToLock > TargetCursor) {

  0077a	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _ByteToLock$35[ebp]
  00780	3b 85 c0 fc ff
	ff		 cmp	 eax, DWORD PTR _TargetCursor$33[ebp]
  00786	76 26		 jbe	 SHORT $LN22@WinMain

; 730  :                             BytesToWrite = (SoundOutput.SecondaryBufferSize - ByteToLock);

  00788	8b 8d ec fc ff
	ff		 mov	 ecx, DWORD PTR _SoundOutput$41[ebp+12]
  0078e	2b 8d c8 fc ff
	ff		 sub	 ecx, DWORD PTR _ByteToLock$35[ebp]
  00794	89 8d d0 fc ff
	ff		 mov	 DWORD PTR _BytesToWrite$37[ebp], ecx

; 731  :                             BytesToWrite += TargetCursor;

  0079a	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _BytesToWrite$37[ebp]
  007a0	03 95 c0 fc ff
	ff		 add	 edx, DWORD PTR _TargetCursor$33[ebp]
  007a6	89 95 d0 fc ff
	ff		 mov	 DWORD PTR _BytesToWrite$37[ebp], edx

; 732  :                         }
; 733  :                         else {

  007ac	eb 12		 jmp	 SHORT $LN23@WinMain
$LN22@WinMain:

; 734  :                             BytesToWrite = TargetCursor - ByteToLock;

  007ae	8b 85 c0 fc ff
	ff		 mov	 eax, DWORD PTR _TargetCursor$33[ebp]
  007b4	2b 85 c8 fc ff
	ff		 sub	 eax, DWORD PTR _ByteToLock$35[ebp]
  007ba	89 85 d0 fc ff
	ff		 mov	 DWORD PTR _BytesToWrite$37[ebp], eax
$LN23@WinMain:

; 735  :                         }
; 736  : 
; 737  :                         SoundIsValid = true;

  007c0	c7 85 a0 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _SoundIsValid$26[ebp], 1
$LN20@WinMain:

; 738  :                     }
; 739  : 
; 740  :                     
; 741  :                     game_sound_output_buffer SoundBuffer = {};

  007ca	33 c9		 xor	 ecx, ecx
  007cc	89 8d 70 fc ff
	ff		 mov	 DWORD PTR _SoundBuffer$20[ebp], ecx
  007d2	89 8d 74 fc ff
	ff		 mov	 DWORD PTR _SoundBuffer$20[ebp+4], ecx
  007d8	89 8d 78 fc ff
	ff		 mov	 DWORD PTR _SoundBuffer$20[ebp+8], ecx

; 742  :                     SoundBuffer.SamplesPerSecond = SoundOutput.SamplesPerSecond;

  007de	8b 95 e0 fc ff
	ff		 mov	 edx, DWORD PTR _SoundOutput$41[ebp]
  007e4	89 95 70 fc ff
	ff		 mov	 DWORD PTR _SoundBuffer$20[ebp], edx

; 743  :                     SoundBuffer.SampleCount = BytesToWrite / SoundOutput.BytesPerSample;

  007ea	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _BytesToWrite$37[ebp]
  007f0	33 d2		 xor	 edx, edx
  007f2	f7 b5 e8 fc ff
	ff		 div	 DWORD PTR _SoundOutput$41[ebp+8]
  007f8	89 85 74 fc ff
	ff		 mov	 DWORD PTR _SoundBuffer$20[ebp+4], eax

; 744  :                     SoundBuffer.Samples = Samples;

  007fe	8b 85 84 fc ff
	ff		 mov	 eax, DWORD PTR _Samples$22[ebp]
  00804	89 85 78 fc ff
	ff		 mov	 DWORD PTR _SoundBuffer$20[ebp+8], eax

; 745  : 
; 746  :                     game_offscreen_buffer Buffer = {};

  0080a	33 c9		 xor	 ecx, ecx
  0080c	89 8d 28 fc ff
	ff		 mov	 DWORD PTR _Buffer$16[ebp], ecx
  00812	89 8d 2c fc ff
	ff		 mov	 DWORD PTR _Buffer$16[ebp+4], ecx
  00818	89 8d 30 fc ff
	ff		 mov	 DWORD PTR _Buffer$16[ebp+8], ecx
  0081e	89 8d 34 fc ff
	ff		 mov	 DWORD PTR _Buffer$16[ebp+12], ecx

; 747  :                     Buffer.Memory = GlobalBackbuffer.Memory;

  00824	8b 15 2c 00 00
	00		 mov	 edx, DWORD PTR ?GlobalBackbuffer@@3Uwin32_offscreen_buffer@@A+44
  0082a	89 95 28 fc ff
	ff		 mov	 DWORD PTR _Buffer$16[ebp], edx

; 748  :                     Buffer.Width = GlobalBackbuffer.Width;

  00830	a1 30 00 00 00	 mov	 eax, DWORD PTR ?GlobalBackbuffer@@3Uwin32_offscreen_buffer@@A+48
  00835	89 85 2c fc ff
	ff		 mov	 DWORD PTR _Buffer$16[ebp+4], eax

; 749  :                     Buffer.Height = GlobalBackbuffer.Height;

  0083b	8b 0d 34 00 00
	00		 mov	 ecx, DWORD PTR ?GlobalBackbuffer@@3Uwin32_offscreen_buffer@@A+52
  00841	89 8d 30 fc ff
	ff		 mov	 DWORD PTR _Buffer$16[ebp+8], ecx

; 750  :                     Buffer.Pitch = GlobalBackbuffer.Pitch;

  00847	8b 15 38 00 00
	00		 mov	 edx, DWORD PTR ?GlobalBackbuffer@@3Uwin32_offscreen_buffer@@A+56
  0084d	89 95 34 fc ff
	ff		 mov	 DWORD PTR _Buffer$16[ebp+12], edx

; 751  :                     GameUpdateAndRender(&GameMemory, NewInput, &Buffer, &SoundBuffer);

  00853	8d 85 70 fc ff
	ff		 lea	 eax, DWORD PTR _SoundBuffer$20[ebp]
  00859	50		 push	 eax
  0085a	8d 8d 28 fc ff
	ff		 lea	 ecx, DWORD PTR _Buffer$16[ebp]
  00860	51		 push	 ecx
  00861	8b 95 c4 fc ff
	ff		 mov	 edx, DWORD PTR _NewInput$34[ebp]
  00867	52		 push	 edx
  00868	8d 85 40 fc ff
	ff		 lea	 eax, DWORD PTR _GameMemory$18[ebp]
  0086e	50		 push	 eax
  0086f	e8 00 00 00 00	 call	 ?GameUpdateAndRender@@YAXPAUgame_memory@@PAUgame_input@@PAUgame_offscreen_buffer@@PAUgame_sound_output_buffer@@@Z ; GameUpdateAndRender
  00874	83 c4 10	 add	 esp, 16			; 00000010H

; 752  : 
; 753  :                     // directsound output test
; 754  :                     if(SoundIsValid) {

  00877	83 bd a0 fc ff
	ff 00		 cmp	 DWORD PTR _SoundIsValid$26[ebp], 0
  0087e	74 24		 je	 SHORT $LN24@WinMain

; 755  :                         
; 756  :                         win32FillSoundBuffer(&SoundOutput, ByteToLock, BytesToWrite, &SoundBuffer);

  00880	8d 8d 70 fc ff
	ff		 lea	 ecx, DWORD PTR _SoundBuffer$20[ebp]
  00886	51		 push	 ecx
  00887	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _BytesToWrite$37[ebp]
  0088d	52		 push	 edx
  0088e	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _ByteToLock$35[ebp]
  00894	50		 push	 eax
  00895	8d 8d e0 fc ff
	ff		 lea	 ecx, DWORD PTR _SoundOutput$41[ebp]
  0089b	51		 push	 ecx
  0089c	e8 00 00 00 00	 call	 ?win32FillSoundBuffer@@YAXPAUwin32_sound_output@@KKPAUgame_sound_output_buffer@@@Z ; win32FillSoundBuffer
  008a1	83 c4 10	 add	 esp, 16			; 00000010H
$LN24@WinMain:

; 757  : 
; 758  :                         // TODO More strenuous test
; 759  :                     }
; 760  : 
; 761  :                     win32_window_dimension Dimension = Win32GetWindowDimension(Window);

  008a4	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR _Window$30[ebp]
  008aa	52		 push	 edx
  008ab	e8 00 00 00 00	 call	 ?Win32GetWindowDimension@@YA?AUwin32_window_dimension@@PAUHWND__@@@Z ; Win32GetWindowDimension
  008b0	83 c4 04	 add	 esp, 4
  008b3	89 85 14 fc ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
  008b9	89 95 18 fc ff
	ff		 mov	 DWORD PTR $T12[ebp+4], edx
  008bf	8b 85 14 fc ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  008c5	89 85 08 fc ff
	ff		 mov	 DWORD PTR _Dimension$10[ebp], eax
  008cb	8b 8d 18 fc ff
	ff		 mov	 ecx, DWORD PTR $T12[ebp+4]
  008d1	89 8d 0c fc ff
	ff		 mov	 DWORD PTR _Dimension$10[ebp+4], ecx

; 762  :                     Win32DisplayBufferInWindow(

  008d7	8b 95 0c fc ff
	ff		 mov	 edx, DWORD PTR _Dimension$10[ebp+4]
  008dd	52		 push	 edx
  008de	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _Dimension$10[ebp]
  008e4	50		 push	 eax
  008e5	8b 8d 24 fc ff
	ff		 mov	 ecx, DWORD PTR _DeviceContext$15[ebp]
  008eb	51		 push	 ecx
  008ec	68 00 00 00 00	 push	 OFFSET ?GlobalBackbuffer@@3Uwin32_offscreen_buffer@@A
  008f1	e8 00 00 00 00	 call	 ?Win32DisplayBufferInWindow@@YAXPAUwin32_offscreen_buffer@@PAUHDC__@@HH@Z ; Win32DisplayBufferInWindow
  008f6	83 c4 10	 add	 esp, 16			; 00000010H

; 763  :                         &GlobalBackbuffer, DeviceContext,
; 764  :                         Dimension.Width, Dimension.Height
; 765  :                     );
; 766  : 
; 767  :                     int64 EndCycleCount = __rdtsc();

  008f9	0f 31		 rdtsc
  008fb	89 85 a4 fc ff
	ff		 mov	 DWORD PTR _EndCycleCount$27[ebp], eax
  00901	89 95 a8 fc ff
	ff		 mov	 DWORD PTR _EndCycleCount$27[ebp+4], edx

; 768  : 
; 769  :                     LARGE_INTEGER EndCounter;
; 770  :                     QueryPerformanceCounter(&EndCounter);

  00907	8d 95 68 fc ff
	ff		 lea	 edx, DWORD PTR _EndCounter$19[ebp]
  0090d	52		 push	 edx
  0090e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4

; 771  : 
; 772  :                     uint64 CyclesElapsed = EndCycleCount - LastCycleCount;

  00914	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _EndCycleCount$27[ebp]
  0091a	2b 85 98 fc ff
	ff		 sub	 eax, DWORD PTR _LastCycleCount$25[ebp]
  00920	8b 8d a8 fc ff
	ff		 mov	 ecx, DWORD PTR _EndCycleCount$27[ebp+4]
  00926	1b 8d 9c fc ff
	ff		 sbb	 ecx, DWORD PTR _LastCycleCount$25[ebp+4]
  0092c	89 85 00 fc ff
	ff		 mov	 DWORD PTR _CyclesElapsed$9[ebp], eax
  00932	89 8d 04 fc ff
	ff		 mov	 DWORD PTR _CyclesElapsed$9[ebp+4], ecx

; 773  :                     int64 CounterElapsed = EndCounter.QuadPart - LastCounter.QuadPart;

  00938	8b 95 68 fc ff
	ff		 mov	 edx, DWORD PTR _EndCounter$19[ebp]
  0093e	2b 95 38 fc ff
	ff		 sub	 edx, DWORD PTR _LastCounter$17[ebp]
  00944	8b 85 6c fc ff
	ff		 mov	 eax, DWORD PTR _EndCounter$19[ebp+4]
  0094a	1b 85 3c fc ff
	ff		 sbb	 eax, DWORD PTR _LastCounter$17[ebp+4]
  00950	89 95 7c fc ff
	ff		 mov	 DWORD PTR _CounterElapsed$21[ebp], edx
  00956	89 85 80 fc ff
	ff		 mov	 DWORD PTR _CounterElapsed$21[ebp+4], eax

; 774  :                     real64 MSPerFrame = (((1000.0f*(real64)CounterElapsed) / (real64)PerfCountFrequency));

  0095c	8b 95 80 fc ff
	ff		 mov	 edx, DWORD PTR _CounterElapsed$21[ebp+4]
  00962	8b 8d 7c fc ff
	ff		 mov	 ecx, DWORD PTR _CounterElapsed$21[ebp]
  00968	e8 00 00 00 00	 call	 __ltod3
  0096d	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@408f400000000000
  00975	8b 95 94 fc ff
	ff		 mov	 edx, DWORD PTR _PerfCountFrequency$[ebp+4]
  0097b	8b 8d 90 fc ff
	ff		 mov	 ecx, DWORD PTR _PerfCountFrequency$[ebp]
  00981	f2 0f 11 85 bc
	fb ff ff	 movsd	 QWORD PTR tv682[ebp], xmm0
  00989	e8 00 00 00 00	 call	 __ltod3
  0098e	f2 0f 10 8d bc
	fb ff ff	 movsd	 xmm1, QWORD PTR tv682[ebp]
  00996	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0099a	f2 0f 11 8d a0
	fb ff ff	 movsd	 QWORD PTR _MSPerFrame$3[ebp], xmm1

; 775  :                     real64 FPS = (real64)PerfCountFrequency / (real64)CounterElapsed;

  009a2	8b 95 94 fc ff
	ff		 mov	 edx, DWORD PTR _PerfCountFrequency$[ebp+4]
  009a8	8b 8d 90 fc ff
	ff		 mov	 ecx, DWORD PTR _PerfCountFrequency$[ebp]
  009ae	e8 00 00 00 00	 call	 __ltod3
  009b3	8b 95 80 fc ff
	ff		 mov	 edx, DWORD PTR _CounterElapsed$21[ebp+4]
  009b9	8b 8d 7c fc ff
	ff		 mov	 ecx, DWORD PTR _CounterElapsed$21[ebp]
  009bf	f2 0f 11 85 b4
	fb ff ff	 movsd	 QWORD PTR tv684[ebp], xmm0
  009c7	e8 00 00 00 00	 call	 __ltod3
  009cc	f2 0f 10 8d b4
	fb ff ff	 movsd	 xmm1, QWORD PTR tv684[ebp]
  009d4	f2 0f 5e c8	 divsd	 xmm1, xmm0
  009d8	f2 0f 11 8d 98
	fb ff ff	 movsd	 QWORD PTR _FPS$2[ebp], xmm1

; 776  :                     real64 MCPF = ((real64)CyclesElapsed / (1000.0f * 1000.0f));

  009e0	8b 95 04 fc ff
	ff		 mov	 edx, DWORD PTR _CyclesElapsed$9[ebp+4]
  009e6	8b 8d 00 fc ff
	ff		 mov	 ecx, DWORD PTR _CyclesElapsed$9[ebp]
  009ec	e8 00 00 00 00	 call	 __ultod3
  009f1	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@412e848000000000
  009f9	f2 0f 11 85 90
	fb ff ff	 movsd	 QWORD PTR _MCPF$1[ebp], xmm0

; 777  :                     
; 778  : 
; 779  :                     // char Buffer[256];
; 780  :                     // sprintf(Buffer, "%.02fms/f,  %.02ff/s,  %.02fmc/f\n", MSPerFrame, FPS, MCPF);
; 781  :                     // OutputDebugStringA(Buffer);
; 782  : 
; 783  :                     // TODO print it
; 784  :                     LastCounter = EndCounter;

  00a01	8b 8d 68 fc ff
	ff		 mov	 ecx, DWORD PTR _EndCounter$19[ebp]
  00a07	89 8d 38 fc ff
	ff		 mov	 DWORD PTR _LastCounter$17[ebp], ecx
  00a0d	8b 95 6c fc ff
	ff		 mov	 edx, DWORD PTR _EndCounter$19[ebp+4]
  00a13	89 95 3c fc ff
	ff		 mov	 DWORD PTR _LastCounter$17[ebp+4], edx

; 785  :                     LastCycleCount = EndCycleCount;

  00a19	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _EndCycleCount$27[ebp]
  00a1f	89 85 98 fc ff
	ff		 mov	 DWORD PTR _LastCycleCount$25[ebp], eax
  00a25	8b 8d a8 fc ff
	ff		 mov	 ecx, DWORD PTR _EndCycleCount$27[ebp+4]
  00a2b	89 8d 9c fc ff
	ff		 mov	 DWORD PTR _LastCycleCount$25[ebp+4], ecx

; 786  : 
; 787  :                     game_input *Temp = NewInput;

  00a31	8b 95 c4 fc ff
	ff		 mov	 edx, DWORD PTR _NewInput$34[ebp]
  00a37	89 95 1c fc ff
	ff		 mov	 DWORD PTR _Temp$13[ebp], edx

; 788  :                     NewInput = OldInput;

  00a3d	8b 85 b0 fc ff
	ff		 mov	 eax, DWORD PTR _OldInput$29[ebp]
  00a43	89 85 c4 fc ff
	ff		 mov	 DWORD PTR _NewInput$34[ebp], eax

; 789  :                     OldInput = Temp;

  00a49	8b 8d 1c fc ff
	ff		 mov	 ecx, DWORD PTR _Temp$13[ebp]
  00a4f	89 8d b0 fc ff
	ff		 mov	 DWORD PTR _OldInput$29[ebp], ecx

; 790  :                     // TODO Clear?
; 791  :                 }

  00a55	e9 f5 f8 ff ff	 jmp	 $LN2@WinMain
$LN3@WinMain:
$LN11@WinMain:
$LN9@WinMain:
$LN7@WinMain:

; 792  :                 //game loop end
; 793  :             }
; 794  :             else {
; 795  :                 // TODO Logging
; 796  :             }
; 797  :         }
; 798  :         else {
; 799  :             // TODO Logging
; 800  :         }
; 801  :     }
; 802  :     else{
; 803  :         // TODO Logging
; 804  :     }
; 805  :     return(0); 

  00a5a	33 c0		 xor	 eax, eax

; 806  : }

  00a5c	5f		 pop	 edi
  00a5d	5e		 pop	 esi
  00a5e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a61	33 cd		 xor	 ecx, ebp
  00a63	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a68	8b e5		 mov	 esp, ebp
  00a6a	5d		 pop	 ebp
  00a6b	c2 10 00	 ret	 16			; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\handmade.cpp
_TEXT	SEGMENT
_Row$ = -20						; size = 4
_Pixel$1 = -16						; size = 4
_Y$2 = -12						; size = 4
_X$3 = -8						; size = 4
_Blue$4 = -3						; size = 1
_Green$5 = -2						; size = 1
_Red$6 = -1						; size = 1
_Buffer$ = 8						; size = 4
_XOffset$ = 12						; size = 4
_YOffset$ = 16						; size = 4
?RenderWeirdGradient@@YAXPAUgame_offscreen_buffer@@HH@Z PROC ; RenderWeirdGradient

; 26   : RenderWeirdGradient(game_offscreen_buffer *Buffer, int XOffset, int YOffset) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 27   :     // TODO lets see which is better
; 28   :     uint8 *Row = (uint8 *)Buffer->Memory;

  00006	8b 45 08	 mov	 eax, DWORD PTR _Buffer$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d ec	 mov	 DWORD PTR _Row$[ebp], ecx

; 29   :     for( int Y = 0 ; Y < Buffer->Height ; ++Y ) {

  0000e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _Y$2[ebp], 0
  00015	eb 09		 jmp	 SHORT $LN4@RenderWeir
$LN2@RenderWeir:
  00017	8b 55 f4	 mov	 edx, DWORD PTR _Y$2[ebp]
  0001a	83 c2 01	 add	 edx, 1
  0001d	89 55 f4	 mov	 DWORD PTR _Y$2[ebp], edx
$LN4@RenderWeir:
  00020	8b 45 08	 mov	 eax, DWORD PTR _Buffer$[ebp]
  00023	8b 4d f4	 mov	 ecx, DWORD PTR _Y$2[ebp]
  00026	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00029	0f 8d 9b 00 00
	00		 jge	 $LN1@RenderWeir

; 30   :         uint32 *Pixel = (uint32 *)Row;

  0002f	8b 55 ec	 mov	 edx, DWORD PTR _Row$[ebp]
  00032	89 55 f0	 mov	 DWORD PTR _Pixel$1[ebp], edx

; 31   :         for( int X = 0 ; X < Buffer->Width ; ++X ) {

  00035	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _X$3[ebp], 0
  0003c	eb 09		 jmp	 SHORT $LN7@RenderWeir
$LN5@RenderWeir:
  0003e	8b 45 f8	 mov	 eax, DWORD PTR _X$3[ebp]
  00041	83 c0 01	 add	 eax, 1
  00044	89 45 f8	 mov	 DWORD PTR _X$3[ebp], eax
$LN7@RenderWeir:
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  0004a	8b 55 f8	 mov	 edx, DWORD PTR _X$3[ebp]
  0004d	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00050	7d 67		 jge	 SHORT $LN6@RenderWeir

; 32   :             uint8 Blue = (uint8)(X - XOffset);

  00052	8b 45 f8	 mov	 eax, DWORD PTR _X$3[ebp]
  00055	2b 45 0c	 sub	 eax, DWORD PTR _XOffset$[ebp]
  00058	88 45 fd	 mov	 BYTE PTR _Blue$4[ebp], al

; 33   :             uint8 Green = (uint8)(Y + YOffset);

  0005b	8b 4d f4	 mov	 ecx, DWORD PTR _Y$2[ebp]
  0005e	03 4d 10	 add	 ecx, DWORD PTR _YOffset$[ebp]
  00061	88 4d fe	 mov	 BYTE PTR _Green$5[ebp], cl

; 34   :             uint8 Red = (uint8)((X - (XOffset/4))*(Y + (YOffset/4))/8);

  00064	8b 45 0c	 mov	 eax, DWORD PTR _XOffset$[ebp]
  00067	99		 cdq
  00068	83 e2 03	 and	 edx, 3
  0006b	03 c2		 add	 eax, edx
  0006d	c1 f8 02	 sar	 eax, 2
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _X$3[ebp]
  00073	2b c8		 sub	 ecx, eax
  00075	8b 45 10	 mov	 eax, DWORD PTR _YOffset$[ebp]
  00078	99		 cdq
  00079	83 e2 03	 and	 edx, 3
  0007c	03 c2		 add	 eax, edx
  0007e	c1 f8 02	 sar	 eax, 2
  00081	03 45 f4	 add	 eax, DWORD PTR _Y$2[ebp]
  00084	0f af c1	 imul	 eax, ecx
  00087	99		 cdq
  00088	83 e2 07	 and	 edx, 7
  0008b	03 c2		 add	 eax, edx
  0008d	c1 f8 03	 sar	 eax, 3
  00090	88 45 ff	 mov	 BYTE PTR _Red$6[ebp], al

; 35   :             *Pixel++ = ((Red << 16) | (Green << 8) | Blue);

  00093	0f b6 55 ff	 movzx	 edx, BYTE PTR _Red$6[ebp]
  00097	c1 e2 10	 shl	 edx, 16			; 00000010H
  0009a	0f b6 45 fe	 movzx	 eax, BYTE PTR _Green$5[ebp]
  0009e	c1 e0 08	 shl	 eax, 8
  000a1	0b d0		 or	 edx, eax
  000a3	0f b6 4d fd	 movzx	 ecx, BYTE PTR _Blue$4[ebp]
  000a7	0b d1		 or	 edx, ecx
  000a9	8b 45 f0	 mov	 eax, DWORD PTR _Pixel$1[ebp]
  000ac	89 10		 mov	 DWORD PTR [eax], edx
  000ae	8b 4d f0	 mov	 ecx, DWORD PTR _Pixel$1[ebp]
  000b1	83 c1 04	 add	 ecx, 4
  000b4	89 4d f0	 mov	 DWORD PTR _Pixel$1[ebp], ecx

; 36   :         }

  000b7	eb 85		 jmp	 SHORT $LN5@RenderWeir
$LN6@RenderWeir:

; 37   :         Row += Buffer->Pitch;

  000b9	8b 55 08	 mov	 edx, DWORD PTR _Buffer$[ebp]
  000bc	8b 45 ec	 mov	 eax, DWORD PTR _Row$[ebp]
  000bf	03 42 0c	 add	 eax, DWORD PTR [edx+12]
  000c2	89 45 ec	 mov	 DWORD PTR _Row$[ebp], eax

; 38   :     }

  000c5	e9 4d ff ff ff	 jmp	 $LN2@RenderWeir
$LN1@RenderWeir:

; 39   : }

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
?RenderWeirdGradient@@YAXPAUgame_offscreen_buffer@@HH@Z ENDP ; RenderWeirdGradient
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\handmade.cpp
_TEXT	SEGMENT
_WavePeriod$ = -24					; size = 4
_SineValue$1 = -20					; size = 4
_SampleIndex$2 = -16					; size = 4
_SampleOut$ = -12					; size = 4
_ToneVolume$ = -8					; size = 2
_SampleValue$3 = -4					; size = 2
_SoundBuffer$ = 8					; size = 4
_ToneHz$ = 12						; size = 4
?GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z PROC ; GameOutputSound

; 6    : GameOutputSound(game_sound_output_buffer *SoundBuffer, int ToneHz) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 7    :     local_persist real32 tSine;
; 8    :     int16 ToneVolume = 3000;

  00006	b8 b8 0b 00 00	 mov	 eax, 3000		; 00000bb8H
  0000b	66 89 45 f8	 mov	 WORD PTR _ToneVolume$[ebp], ax

; 9    :     // int ToneHz = 256;
; 10   :     int WavePeriod = SoundBuffer->SamplesPerSecond/ToneHz;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _SoundBuffer$[ebp]
  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	99		 cdq
  00015	f7 7d 0c	 idiv	 DWORD PTR _ToneHz$[ebp]
  00018	89 45 e8	 mov	 DWORD PTR _WavePeriod$[ebp], eax

; 11   :     
; 12   :     int16 *SampleOut = SoundBuffer->Samples; 

  0001b	8b 55 08	 mov	 edx, DWORD PTR _SoundBuffer$[ebp]
  0001e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00021	89 45 f4	 mov	 DWORD PTR _SampleOut$[ebp], eax

; 13   :     for(int SampleIndex = 0; SampleIndex < SoundBuffer->SampleCount; ++SampleIndex) {

  00024	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _SampleIndex$2[ebp], 0
  0002b	eb 09		 jmp	 SHORT $LN4@GameOutput
$LN2@GameOutput:
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _SampleIndex$2[ebp]
  00030	83 c1 01	 add	 ecx, 1
  00033	89 4d f0	 mov	 DWORD PTR _SampleIndex$2[ebp], ecx
$LN4@GameOutput:
  00036	8b 55 08	 mov	 edx, DWORD PTR _SoundBuffer$[ebp]
  00039	8b 45 f0	 mov	 eax, DWORD PTR _SampleIndex$2[ebp]
  0003c	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0003f	7d 7a		 jge	 SHORT $LN3@GameOutput

; 14   :         real32 SineValue = sinf(tSine);

  00041	51		 push	 ecx
  00042	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?tSine@?1??GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z@4MA
  0004a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004f	e8 00 00 00 00	 call	 _sinf
  00054	83 c4 04	 add	 esp, 4
  00057	d9 5d ec	 fstp	 DWORD PTR _SineValue$1[ebp]

; 15   :         int16 SampleValue = (int16)(SineValue * ToneVolume);

  0005a	0f bf 4d f8	 movsx	 ecx, WORD PTR _ToneVolume$[ebp]
  0005e	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00062	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _SineValue$1[ebp]
  00067	f3 0f 2c d0	 cvttss2si edx, xmm0
  0006b	66 89 55 fc	 mov	 WORD PTR _SampleValue$3[ebp], dx

; 16   :         *SampleOut++ = SampleValue;

  0006f	8b 45 f4	 mov	 eax, DWORD PTR _SampleOut$[ebp]
  00072	66 8b 4d fc	 mov	 cx, WORD PTR _SampleValue$3[ebp]
  00076	66 89 08	 mov	 WORD PTR [eax], cx
  00079	8b 55 f4	 mov	 edx, DWORD PTR _SampleOut$[ebp]
  0007c	83 c2 02	 add	 edx, 2
  0007f	89 55 f4	 mov	 DWORD PTR _SampleOut$[ebp], edx

; 17   :         *SampleOut++ = SampleValue;

  00082	8b 45 f4	 mov	 eax, DWORD PTR _SampleOut$[ebp]
  00085	66 8b 4d fc	 mov	 cx, WORD PTR _SampleValue$3[ebp]
  00089	66 89 08	 mov	 WORD PTR [eax], cx
  0008c	8b 55 f4	 mov	 edx, DWORD PTR _SampleOut$[ebp]
  0008f	83 c2 02	 add	 edx, 2
  00092	89 55 f4	 mov	 DWORD PTR _SampleOut$[ebp], edx

; 18   : 
; 19   :         tSine += 2.0f*Pi32*1.0f/(real32)WavePeriod;

  00095	f3 0f 2a 45 e8	 cvtsi2ss xmm0, DWORD PTR _WavePeriod$[ebp]
  0009a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40c90fdb
  000a2	f3 0f 5e c8	 divss	 xmm1, xmm0
  000a6	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR ?tSine@?1??GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z@4MA
  000ae	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR ?tSine@?1??GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z@4MA, xmm1

; 20   :     }

  000b6	e9 72 ff ff ff	 jmp	 $LN2@GameOutput
$LN3@GameOutput:

; 21   : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z ENDP ; GameOutputSound
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\handmade.cpp
_TEXT	SEGMENT
$T1 = -32						; size = 8
_File$2 = -24						; size = 8
_Filename$3 = -16					; size = 4
tv146 = -12						; size = 4
_Input0$ = -8						; size = 4
_GameState$ = -4					; size = 4
_Memory$ = 8						; size = 4
_Input$ = 12						; size = 4
_Buffer$ = 16						; size = 4
_SoundBuffer$ = 20					; size = 4
?GameUpdateAndRender@@YAXPAUgame_memory@@PAUgame_input@@PAUgame_offscreen_buffer@@PAUgame_sound_output_buffer@@@Z PROC ; GameUpdateAndRender

; 49   : ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 50   :     Assert(sizeof(game_state) <= Memory->PermanentStorageSize);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Memory$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR tv146[ebp], eax
  0000c	8b 4d f4	 mov	 ecx, DWORD PTR tv146[ebp]
  0000f	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00013	77 15		 ja	 SHORT $LN2@GameUpdate
  00015	72 09		 jb	 SHORT $LN9@GameUpdate
  00017	8b 55 f4	 mov	 edx, DWORD PTR tv146[ebp]
  0001a	83 7a 08 0c	 cmp	 DWORD PTR [edx+8], 12	; 0000000cH
  0001e	73 0a		 jae	 SHORT $LN2@GameUpdate
$LN9@GameUpdate:
  00020	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ds:0, 0
$LN2@GameUpdate:

; 51   :     game_state *GameState = (game_state *)Memory->PermanentStorage;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _Memory$[ebp]
  0002d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00030	89 4d fc	 mov	 DWORD PTR _GameState$[ebp], ecx

; 52   :     if (!Memory->IsInitialized) {

  00033	8b 55 08	 mov	 edx, DWORD PTR _Memory$[ebp]
  00036	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00039	75 5e		 jne	 SHORT $LN3@GameUpdate

; 53   :         char *Filename = __FILE__;

  0003b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Filename$3[ebp], OFFSET $SG3988

; 54   : 
; 55   :         debug_read_file_result File = DEBUGPlatformReadEntireFile(Filename);

  00042	8b 45 f0	 mov	 eax, DWORD PTR _Filename$3[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?DEBUGPlatformReadEntireFile@@YA?AUdebug_read_file_result@@PAD@Z ; DEBUGPlatformReadEntireFile
  0004b	83 c4 04	 add	 esp, 4
  0004e	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
  00051	89 55 e4	 mov	 DWORD PTR $T1[ebp+4], edx
  00054	8b 4d e0	 mov	 ecx, DWORD PTR $T1[ebp]
  00057	89 4d e8	 mov	 DWORD PTR _File$2[ebp], ecx
  0005a	8b 55 e4	 mov	 edx, DWORD PTR $T1[ebp+4]
  0005d	89 55 ec	 mov	 DWORD PTR _File$2[ebp+4], edx

; 56   :         if(File.Contents) {

  00060	83 7d ec 00	 cmp	 DWORD PTR _File$2[ebp+4], 0
  00064	74 21		 je	 SHORT $LN4@GameUpdate

; 57   :             DEBUGPlatformWriteEntireFile("test.out", File.ContentsSize, File.Contents);

  00066	8b 45 ec	 mov	 eax, DWORD PTR _File$2[ebp+4]
  00069	50		 push	 eax
  0006a	8b 4d e8	 mov	 ecx, DWORD PTR _File$2[ebp]
  0006d	51		 push	 ecx
  0006e	68 00 00 00 00	 push	 OFFSET $SG3990
  00073	e8 00 00 00 00	 call	 ?DEBUGPlatformWriteEntireFile@@YAHPADIPAX@Z ; DEBUGPlatformWriteEntireFile
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH

; 58   :             DEBUGPlatformFreeFileMemory(File.Contents);

  0007b	8b 55 ec	 mov	 edx, DWORD PTR _File$2[ebp+4]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 ?DEBUGPlatformFreeFileMemory@@YAXPAX@Z ; DEBUGPlatformFreeFileMemory
  00084	83 c4 04	 add	 esp, 4
$LN4@GameUpdate:

; 59   :         }
; 60   :         GameState->ToneHz = 256;

  00087	8b 45 fc	 mov	 eax, DWORD PTR _GameState$[ebp]
  0008a	c7 00 00 01 00
	00		 mov	 DWORD PTR [eax], 256	; 00000100H

; 61   : 
; 62   :         // TODO This may be more appropriate to do in the platform layer
; 63   :         Memory->IsInitialized = true;

  00090	8b 4d 08	 mov	 ecx, DWORD PTR _Memory$[ebp]
  00093	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1
$LN3@GameUpdate:

; 64   :     }
; 65   : 
; 66   :     game_controller_input *Input0 = &Input->Controllers[0];

  00099	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  0009e	6b c2 00	 imul	 eax, edx, 0
  000a1	03 45 0c	 add	 eax, DWORD PTR _Input$[ebp]
  000a4	89 45 f8	 mov	 DWORD PTR _Input0$[ebp], eax

; 67   :     if(Input0->IsAnalogue) {

  000a7	8b 4d f8	 mov	 ecx, DWORD PTR _Input0$[ebp]
  000aa	83 39 00	 cmp	 DWORD PTR [ecx], 0
  000ad	74 3f		 je	 SHORT $LN5@GameUpdate

; 68   :         // Use analogue movement tuning
; 69   :         GameState->XOffset += (int)(4.0f*(Input0->EndX));

  000af	8b 55 f8	 mov	 edx, DWORD PTR _Input0$[ebp]
  000b2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  000ba	f3 0f 59 42 1c	 mulss	 xmm0, DWORD PTR [edx+28]
  000bf	f3 0f 2c c0	 cvttss2si eax, xmm0
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _GameState$[ebp]
  000c6	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c9	8b 55 fc	 mov	 edx, DWORD PTR _GameState$[ebp]
  000cc	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 70   :         GameState->ToneHz = 256 + (int)(128.0f*(Input0->EndY));

  000cf	8b 45 f8	 mov	 eax, DWORD PTR _Input0$[ebp]
  000d2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43000000
  000da	f3 0f 59 40 20	 mulss	 xmm0, DWORD PTR [eax+32]
  000df	f3 0f 2c c8	 cvttss2si ecx, xmm0
  000e3	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  000e9	8b 55 fc	 mov	 edx, DWORD PTR _GameState$[ebp]
  000ec	89 0a		 mov	 DWORD PTR [edx], ecx
$LN5@GameUpdate:

; 71   :     }
; 72   :     else {
; 73   :         // Use digital movement tuning
; 74   :     }
; 75   : 
; 76   :     if(Input0->Down.EndedDown) {

  000ee	8b 45 f8	 mov	 eax, DWORD PTR _Input0$[ebp]
  000f1	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  000f5	74 0f		 je	 SHORT $LN7@GameUpdate

; 77   :         GameState->YOffset += 1;

  000f7	8b 4d fc	 mov	 ecx, DWORD PTR _GameState$[ebp]
  000fa	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000fd	83 c2 01	 add	 edx, 1
  00100	8b 45 fc	 mov	 eax, DWORD PTR _GameState$[ebp]
  00103	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN7@GameUpdate:

; 78   :     }
; 79   : 
; 80   : 
; 81   :     // TODO Allow sample offsets here for more robust platform
; 82   :     GameOutputSound(SoundBuffer, GameState->ToneHz);

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _GameState$[ebp]
  00109	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010b	52		 push	 edx
  0010c	8b 45 14	 mov	 eax, DWORD PTR _SoundBuffer$[ebp]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ?GameOutputSound@@YAXPAUgame_sound_output_buffer@@H@Z ; GameOutputSound
  00115	83 c4 08	 add	 esp, 8

; 83   :     RenderWeirdGradient(Buffer, GameState->XOffset, GameState->YOffset);

  00118	8b 4d fc	 mov	 ecx, DWORD PTR _GameState$[ebp]
  0011b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0011e	52		 push	 edx
  0011f	8b 45 fc	 mov	 eax, DWORD PTR _GameState$[ebp]
  00122	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00125	51		 push	 ecx
  00126	8b 55 10	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00129	52		 push	 edx
  0012a	e8 00 00 00 00	 call	 ?RenderWeirdGradient@@YAXPAUgame_offscreen_buffer@@HH@Z ; RenderWeirdGradient
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 84   : }

  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
?GameUpdateAndRender@@YAXPAUgame_memory@@PAUgame_input@@PAUgame_offscreen_buffer@@PAUgame_sound_output_buffer@@@Z ENDP ; GameUpdateAndRender
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_BytesWritten$1 = -16					; size = 4
_Result$ = -12						; size = 4
tv81 = -8						; size = 4
_FileHandle$ = -4					; size = 4
_Filename$ = 8						; size = 4
_MemorySize$ = 12					; size = 4
_Memory$ = 16						; size = 4
?DEBUGPlatformWriteEntireFile@@YAHPADIPAX@Z PROC	; DEBUGPlatformWriteEntireFile

; 152  : DEBUGPlatformWriteEntireFile(char *Filename, uint32 MemorySize, void *Memory) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 153  :     bool32 Result = false;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 0

; 154  : 
; 155  :     HANDLE FileHandle = CreateFile(Filename, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0);

  0000d	6a 00		 push	 0
  0000f	6a 00		 push	 0
  00011	6a 02		 push	 2
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	68 00 00 00 40	 push	 1073741824		; 40000000H
  0001c	8b 45 08	 mov	 eax, DWORD PTR _Filename$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00026	89 45 fc	 mov	 DWORD PTR _FileHandle$[ebp], eax

; 156  : 
; 157  :     if (FileHandle != INVALID_HANDLE_VALUE) {

  00029	83 7d fc ff	 cmp	 DWORD PTR _FileHandle$[ebp], -1
  0002d	74 44		 je	 SHORT $LN3@DEBUGPlatf

; 158  :         DWORD BytesWritten;
; 159  :                 
; 160  :         if(WriteFile(FileHandle, Memory, MemorySize, &BytesWritten, 0)) {

  0002f	6a 00		 push	 0
  00031	8d 4d f0	 lea	 ecx, DWORD PTR _BytesWritten$1[ebp]
  00034	51		 push	 ecx
  00035	8b 55 0c	 mov	 edx, DWORD PTR _MemorySize$[ebp]
  00038	52		 push	 edx
  00039	8b 45 10	 mov	 eax, DWORD PTR _Memory$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _FileHandle$[ebp]
  00040	51		 push	 ecx
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00047	85 c0		 test	 eax, eax
  00049	74 1e		 je	 SHORT $LN5@DEBUGPlatf

; 161  :             // NOTE File read successfully
; 162  :             Result = (BytesWritten == MemorySize);

  0004b	8b 55 f0	 mov	 edx, DWORD PTR _BytesWritten$1[ebp]
  0004e	3b 55 0c	 cmp	 edx, DWORD PTR _MemorySize$[ebp]
  00051	75 09		 jne	 SHORT $LN7@DEBUGPlatf
  00053	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv81[ebp], 1
  0005a	eb 07		 jmp	 SHORT $LN8@DEBUGPlatf
$LN7@DEBUGPlatf:
  0005c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$LN8@DEBUGPlatf:
  00063	8b 45 f8	 mov	 eax, DWORD PTR tv81[ebp]
  00066	89 45 f4	 mov	 DWORD PTR _Result$[ebp], eax
$LN5@DEBUGPlatf:

; 163  :         }
; 164  :         else {
; 165  :             // TODO logging
; 166  :         }
; 167  : 
; 168  :         CloseHandle(FileHandle);

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _FileHandle$[ebp]
  0006c	51		 push	 ecx
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN3@DEBUGPlatf:

; 169  :     }
; 170  :     else {
; 171  :         // TODO logging
; 172  :     }
; 173  : 
; 174  :     return(Result);

  00073	8b 45 f4	 mov	 eax, DWORD PTR _Result$[ebp]

; 175  : 
; 176  : 
; 177  : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?DEBUGPlatformWriteEntireFile@@YAHPADIPAX@Z ENDP	; DEBUGPlatformWriteEntireFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_Memory$ = 8						; size = 4
?DEBUGPlatformFreeFileMemory@@YAXPAX@Z PROC		; DEBUGPlatformFreeFileMemory

; 143  : DEBUGPlatformFreeFileMemory(void *Memory) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 144  :     if(Memory) {

  00003	83 7d 08 00	 cmp	 DWORD PTR _Memory$[ebp], 0
  00007	74 11		 je	 SHORT $LN1@DEBUGPlatf

; 145  :         VirtualFree(Memory, 0, MEM_RELEASE);

  00009	68 00 80 00 00	 push	 32768			; 00008000H
  0000e	6a 00		 push	 0
  00010	8b 45 08	 mov	 eax, DWORD PTR _Memory$[ebp]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFree@12
$LN1@DEBUGPlatf:

; 146  :     }
; 147  : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?DEBUGPlatformFreeFileMemory@@YAXPAX@Z ENDP		; DEBUGPlatformFreeFileMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File p:\handmade\code\win32_handmade.cpp
_TEXT	SEGMENT
_FileSize$1 = -28					; size = 8
_Result$ = -20						; size = 8
_BytesRead$2 = -12					; size = 4
_FileHandle$ = -8					; size = 4
_FileSize32$3 = -4					; size = 4
_Filename$ = 8						; size = 4
?DEBUGPlatformReadEntireFile@@YA?AUdebug_read_file_result@@PAD@Z PROC ; DEBUGPlatformReadEntireFile

; 98   : DEBUGPlatformReadEntireFile(char *Filename) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 99   :     debug_read_file_result Result = {};

  00006	33 c0		 xor	 eax, eax
  00008	89 45 ec	 mov	 DWORD PTR _Result$[ebp], eax
  0000b	89 45 f0	 mov	 DWORD PTR _Result$[ebp+4], eax

; 100  : 
; 101  :     HANDLE FileHandle = CreateFile(Filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);

  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	6a 03		 push	 3
  00014	6a 00		 push	 0
  00016	6a 01		 push	 1
  00018	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _Filename$[ebp]
  00020	51		 push	 ecx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00027	89 45 f8	 mov	 DWORD PTR _FileHandle$[ebp], eax

; 102  : 
; 103  :     if (FileHandle != INVALID_HANDLE_VALUE) {

  0002a	83 7d f8 ff	 cmp	 DWORD PTR _FileHandle$[ebp], -1
  0002e	0f 84 8a 00 00
	00		 je	 $LN3@DEBUGPlatf

; 104  :         LARGE_INTEGER FileSize;
; 105  : 
; 106  :         if(GetFileSizeEx(FileHandle, &FileSize)) {

  00034	8d 55 e4	 lea	 edx, DWORD PTR _FileSize$1[ebp]
  00037	52		 push	 edx
  00038	8b 45 f8	 mov	 eax, DWORD PTR _FileHandle$[ebp]
  0003b	50		 push	 eax
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSizeEx@8
  00042	85 c0		 test	 eax, eax
  00044	74 6e		 je	 SHORT $LN5@DEBUGPlatf

; 107  :             // TODO Defines for maximum values
; 108  :             uint32 FileSize32 = SafeTruncateUInt64(FileSize.QuadPart);

  00046	8b 4d e8	 mov	 ecx, DWORD PTR _FileSize$1[ebp+4]
  00049	51		 push	 ecx
  0004a	8b 55 e4	 mov	 edx, DWORD PTR _FileSize$1[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 ?SafeTruncateUInt64@@YAI_K@Z ; SafeTruncateUInt64
  00053	83 c4 08	 add	 esp, 8
  00056	89 45 fc	 mov	 DWORD PTR _FileSize32$3[ebp], eax

; 109  :             Result.Contents = VirtualAlloc(0, FileSize32, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

  00059	6a 04		 push	 4
  0005b	68 00 30 00 00	 push	 12288			; 00003000H
  00060	8b 45 fc	 mov	 eax, DWORD PTR _FileSize32$3[ebp]
  00063	50		 push	 eax
  00064	6a 00		 push	 0
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
  0006c	89 45 f0	 mov	 DWORD PTR _Result$[ebp+4], eax

; 110  : 
; 111  :             if(Result.Contents) {

  0006f	83 7d f0 00	 cmp	 DWORD PTR _Result$[ebp+4], 0
  00073	74 3f		 je	 SHORT $LN5@DEBUGPlatf

; 112  :                 DWORD BytesRead;
; 113  :                 
; 114  :                 if(ReadFile(FileHandle, Result.Contents, FileSize32, &BytesRead, 0) && (FileSize32 == BytesRead)) {

  00075	6a 00		 push	 0
  00077	8d 4d f4	 lea	 ecx, DWORD PTR _BytesRead$2[ebp]
  0007a	51		 push	 ecx
  0007b	8b 55 fc	 mov	 edx, DWORD PTR _FileSize32$3[ebp]
  0007e	52		 push	 edx
  0007f	8b 45 f0	 mov	 eax, DWORD PTR _Result$[ebp+4]
  00082	50		 push	 eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR _FileHandle$[ebp]
  00086	51		 push	 ecx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  0008d	85 c0		 test	 eax, eax
  0008f	74 10		 je	 SHORT $LN8@DEBUGPlatf
  00091	8b 55 fc	 mov	 edx, DWORD PTR _FileSize32$3[ebp]
  00094	3b 55 f4	 cmp	 edx, DWORD PTR _BytesRead$2[ebp]
  00097	75 08		 jne	 SHORT $LN8@DEBUGPlatf

; 115  :                     // NOTE File read successfully
; 116  :                     Result.ContentsSize = FileSize32;

  00099	8b 45 fc	 mov	 eax, DWORD PTR _FileSize32$3[ebp]
  0009c	89 45 ec	 mov	 DWORD PTR _Result$[ebp], eax

; 117  :                 }
; 118  :                 else {

  0009f	eb 13		 jmp	 SHORT $LN5@DEBUGPlatf
$LN8@DEBUGPlatf:

; 119  :                     DEBUGPlatformFreeFileMemory(Result.Contents);

  000a1	8b 4d f0	 mov	 ecx, DWORD PTR _Result$[ebp+4]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 ?DEBUGPlatformFreeFileMemory@@YAXPAX@Z ; DEBUGPlatformFreeFileMemory
  000aa	83 c4 04	 add	 esp, 4

; 120  :                     Result.Contents = 0;

  000ad	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp+4], 0
$LN5@DEBUGPlatf:

; 121  :                 }
; 122  :             }
; 123  :             else {
; 124  :                 // TODO logging
; 125  :             }
; 126  :         }
; 127  :         else {
; 128  :             // TODO logging
; 129  :         }
; 130  : 
; 131  :         CloseHandle(FileHandle);

  000b4	8b 55 f8	 mov	 edx, DWORD PTR _FileHandle$[ebp]
  000b7	52		 push	 edx
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN3@DEBUGPlatf:

; 132  :     }
; 133  :     else {
; 134  :         // TODO logging
; 135  :     }
; 136  : 
; 137  :     return(Result);

  000be	8b 45 ec	 mov	 eax, DWORD PTR _Result$[ebp]
  000c1	8b 55 f0	 mov	 edx, DWORD PTR _Result$[ebp+4]

; 138  : }

  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
?DEBUGPlatformReadEntireFile@@YA?AUdebug_read_file_result@@PAD@Z ENDP ; DEBUGPlatformReadEntireFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10056.0\ucrt\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv70 = -4						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 736  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 737  :         return (float)sin(_X);

  00004	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00009	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
  0000e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00012	f3 0f 11 45 fc	 movss	 DWORD PTR tv70[ebp], xmm0
  00017	d9 45 fc	 fld	 DWORD PTR tv70[ebp]

; 738  :     }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_sinf	ENDP
_TEXT	ENDS
END
